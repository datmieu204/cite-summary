{
    "ID": "P00-1025",
    "citations": [
        {
            "Number": 1,
            "refer_ID": "P00-1025",
            "refer_sids": [
                29
            ],
            "refer_text": "If the relation is finite-state, then it can be defined using the metalanguage of regular expressions; and, with a suitable compiler, the regular expression source code can be compiled into a finite-state transducer (fst), as shown in Figure 4, that implements the relation computationally.",
            "cite_ID": "J06-1004",
            "cite_maker_sids": [
                104
            ],
            "cite_sids": [
                104
            ],
            "cite_text": "Beesley and Karttunen (2000) describe a technique, called compile-replace, for constructing FSTs, which involves reapplying the regular-expression compiler to its own output.",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 2,
            "refer_ID": "P00-1025",
            "refer_sids": [
                123
            ],
            "refer_text": "This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime.",
            "cite_ID": "P55-62_p00",
            "cite_maker_sids": [
                52
            ],
            "cite_sids": [
                52
            ],
            "cite_text": "Beesleyl7l presents a finite-state morphological analyzer for Arabic, which displays the root, pattern and prefixes/suffixes.",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 3,
            "refer_ID": "P00-1025",
            "refer_sids": [
                203
            ],
            "refer_text": "Significant experiments with Malay and a much larger application in Arabic have shown the value of this technique in handling two classic examples of non-concatenative morphotactics: full-stem reduplication and Semitic stem interdigitation.",
            "cite_ID": "P9852_p00",
            "cite_maker_sids": [
                200,
                201
            ],
            "cite_sids": [
                200,
                201
            ],
            "cite_text": "Thus, we employ the com pile-replace feature in xfst (Beesley & Karttunen, 2000). This feature allows the repetition of arbi trarily complex sublanguages by specifying the brackets '\"'[ \" and \"A 1 \" to mark the domain of re duplication.",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 5,
            "refer_ID": "P00-1025",
            "refer_sids": [
                62
            ],
            "refer_text": "The compile- replace algorithm then reapplies the regular- expression compiler to its own output, compiling the regular-expression substrings in the intermediate network and replacing them with the result of the compilation.",
            "cite_ID": "PE2006_p00",
            "cite_maker_sids": [
                104
            ],
            "cite_sids": [
                104
            ],
            "cite_text": "Beesley and Karttunen (2000) describe a technique, called compile-replace, for constructing FSTs, which involves reapplying the regular-expression compiler to its own output.",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 6,
            "refer_ID": "P00-1025",
            "refer_sids": [
                119
            ],
            "refer_text": "In work more directly related to the current solution, it was Kataja and Koskenniemi (1988) who first demonstrated that Semitic (Akkadian) roots and patterns5 could be formalized as regular languages, and that the non-concatenative interdigitation of stems could be elegantly formalized as the intersection of those regular languages.",
            "cite_ID": "Plex_p00",
            "cite_maker_sids": [
                31
            ],
            "cite_sids": [
                31
            ],
            "cite_text": "Challenging non-concatenative morphological phenomena, such as circumfixion and root-and-pattern morphology, can be characterized by regular means (Beesley and Karttunen 2000, 2003).",
            "label": [
                "Result Citation"
            ]
        },
        {
            "Number": 7,
            "refer_ID": "P00-1025",
            "refer_sids": [
                16
            ],
            "refer_text": "This technique, implemented in an algorithm called compile-replace, has already proved useful for handling Malay full- stem reduplication and Arabic stem interdigitation, which will be described below.",
            "cite_ID": "Plex_p00",
            "cite_maker_sids": [
                32
            ],
            "cite_sids": [
                32
            ],
            "cite_text": "Even total reduplication can be characterized without going outside the regular languages (Beesley and Karttunen 2000).",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 8,
            "refer_ID": "P00-1025",
            "refer_sids": [
                96
            ],
            "refer_text": "In the regular expression calculus there are several operators that involve concatenation.",
            "cite_ID": "Pmorph_p00",
            "cite_maker_sids": [
                67
            ],
            "cite_sids": [
                67
            ],
            "cite_text": "In this section we will show in detail how Realizational Morphology can be expressed in terms of the parc/xrce regular expression calculus as dened in Beesley and Karttunen [4].",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 10,
            "refer_ID": "P00-1025",
            "refer_sids": [
                131
            ],
            "refer_text": "3.2.2 Merge The merge algorithm is a pattern-filling operation that combines two regular languages, a template and a filler, into a single one.",
            "cite_ID": "Pstat_p00",
            "cite_maker_sids": [
                86
            ],
            "cite_sids": [
                86
            ],
            "cite_text": "The application of the merge algorithm to the lower-side of the relation is performed by the COMPILER EPL ACE algorithm (Beesley and Karttunen, 2000),11 and the result is shown in Figure 7.",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 11,
            "refer_ID": "P00-1025",
            "refer_sids": [
                202
            ],
            "refer_text": "The technique described here, implemented in the compile-replace algorithm, allows the regular-expression compiler to reapply to and modify its own output, effectively freeing morphotactic description to use any finite-state operation.",
            "cite_ID": "W02-0503-parscit130908",
            "cite_maker_sids": [
                17
            ],
            "cite_sids": [
                17
            ],
            "cite_text": "Beesley and Karttunen (2000) described a new technique for constructing finite-state transducers that involves reapplying a regular-expression compiler to its own output.",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 12,
            "refer_ID": "P00-1025",
            "refer_sids": [
                123
            ],
            "refer_text": "This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime.",
            "cite_ID": "W07-0802-parscit130908",
            "cite_maker_sids": [
                134
            ],
            "cite_sids": [
                134
            ],
            "cite_text": "A large-scale implementation of the Arabic morphological system is the Xerox Arabic Morphologi cal Analyzer and Generator (Beesley and Karttunen,2000; Beesley, 2001).",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 13,
            "refer_ID": "P00-1025",
            "refer_sids": [
                50
            ],
            "refer_text": "All the finite-state operations (concatenation, union, intersection, composition, etc.) can be simulated by an apply routine at runtime.",
            "cite_ID": "W08-0703",
            "cite_maker_sids": [
                15
            ],
            "cite_sids": [
                15
            ],
            "cite_text": "In the last decade, finite-state approaches to phonology (Gildea and Jurafsky, 1996; Beesley and Karttunen, 2000) have effectively brought theoretical linguistic work on rewrite rules into the computational realm.",
            "label": [
                "Method Citation"
            ]
        },
        {
            "Number": 14,
            "refer_ID": "P00-1025",
            "refer_sids": [
                205
            ],
            "refer_text": "The compile-replace algorithm and the merge operator introduced in this paper are general techniques not limited to handling the specific",
            "cite_ID": "W09-0802",
            "cite_maker_sids": [
                207
            ],
            "cite_sids": [
                207
            ],
            "cite_text": "The interdigitation is handled using a compile-replace process using the replace operator (Karttunen and Beesley, 2000) (Karttunen, 1995).",
            "label": [
                "Method Citation"
            ]
        }
    ]
}