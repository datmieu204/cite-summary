{
    "ID": "D09-1161",
    "sections": [
        {
            "text": "abstract",
            "number": 0,
            "sents": [
                {
                    "text": "K-Best Combination of Syntactic Parsers",
                    "sid": 0,
                    "ssid": null,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper, we propose a linear model-based general framework to combine k-best parse outputs from multiple parsers.",
                    "sid": 1,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The proposed framework leverages on the strengths of previous system combination and re-ranking techniques in parsing by integrating them into a linear model.",
                    "sid": 2,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As a result, it is able to fully utilize both the logarithm of the probability of each k-best parse tree from each individual parser and any additional useful features.",
                    "sid": 3,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For feature weight tuning, we compare the simulated-annealing algorithm and the perceptron algorithm.",
                    "sid": 4,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our experiments are carried out on both the Chinese and English Penn Treebank syntactic parsing task by combining two stateof-the-art parsing models, a head-driven lexicalized model and a latent-annotation-based un-lexicalized model.",
                    "sid": 5,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Experimental results show that our F-Scores of 85.45 on Chinese and 92.62 on English outperform the previously best-reported systems by 1.21 and 0.52, respectively.",
                    "sid": 6,
                    "ssid": 6,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "1 introduction",
            "number": "1",
            "sents": [
                {
                    "text": "Statistical models have achieved great success in language parsing and obtained the state-of-theart results in a variety of languages.",
                    "sid": 7,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In general, they can be divided into two major categories, namely lexicalized models (Collins 1997, 1999; Charniak 1997, 2000) and un-lexicalized models (Klein and Manning 2003; Matsuzaki et al. 2005; Petrov et al.",
                    "sid": 8,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "2006; Petrov and Klein 2007).",
                    "sid": 9,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In lexicalized models, word information play a key role in modeling grammar rule generation, while un-lexicalized models usually utilize latent information derived from the parse structure diversity.",
                    "sid": 10,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Although the two models are different from each other in essence, both have achieved stateof-the-art results in a variety of languages and are complementary to each other (this will be empirically verified later in this paper).",
                    "sid": 11,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore, it is natural to combine the two models for better parsing performance.",
                    "sid": 12,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Besides individual parsing models, many system combination methods for parsing have been proposed (Henderson and Brill 1999; Zeman and \u017dabokrtsk\u00fd 2005; Sagae and Lavie 2006) and promising performance improvements have been reported.",
                    "sid": 13,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In addition, parsing re-ranking (Collins 2000; Riezler et al. 2002; Charniak and Johnson 2005; Huang 2008) has also been shown to be another effective technique to improve parsing performance.",
                    "sid": 14,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This technique utilizes a bunch of linguistic features to re-rank the k-best (Huang and Chiang 2005) output on the forest level or tree level.",
                    "sid": 15,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In prior work, system combination was applied on multiple parsers while re-ranking was applied on the k-best outputs of individual parsers.",
                    "sid": 16,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper, we propose a linear model-based general framework for multiple parsers combination.",
                    "sid": 17,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The proposed framework leverages on the strengths of previous system combination and reranking methods and is open to any type of features.",
                    "sid": 18,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In particular, it is capable of utilizing the logarithm of the parse tree probability from each individual parser while previous combination methods are unable to use this feature since the probabilities from different parsers are not comparable.",
                    "sid": 19,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In addition, we experiment on k-best combination while previous methods are only verified on 1-best combination.",
                    "sid": 20,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Finally, we apply our method in combining outputs from both the lexicalized and un-lexicalized parsers while previous methods only carry out experiments on multiple lexicalized parsers.",
                    "sid": 21,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We also compare two learning algorithms in tuning the feature weights for the linear model.",
                    "sid": 22,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We perform extensive experiments on the Chinese and English Penn Treebank corpus.",
                    "sid": 23,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Experimental results show that our final results, an F-Score of 92.62 on English and 85.45 on Chinese, outperform the previously best-reported systems by 0.52 point and 1.21 point, respectively.",
                    "sid": 24,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This convincingly demonstrates the effectiveness of our proposed framework.",
                    "sid": 25,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our study also shows that the simulated-annealing algorithm (Kirkpatrick et al. 1983) is more effective than the perceptron algorithm (Collins 2002) for feature weight tuning.",
                    "sid": 26,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The rest of this paper is organized as follows.",
                    "sid": 27,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Section 2 briefly reviews related work.",
                    "sid": 28,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Section 3 discusses our method while section 4 presents the feature weight tuning algorithm.",
                    "sid": 29,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In Section 5, we report our experimental results and then conclude in Section 6.",
                    "sid": 30,
                    "ssid": 24,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "2 related work",
            "number": "2",
            "sents": [
                {
                    "text": "As discussed in the previous section, system combination and re-ranking are two techniques to improve parsing performance by postprocessing parsers\u2019 k-best outputs.",
                    "sid": 31,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Regarding the system combination study, Henderson and Brill (1999) propose two parser combination schemes, one that selects an entire tree from one of the parsers, and one that builds a new tree by selecting constituents suggested by the initial trees.",
                    "sid": 32,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "According to the second scheme, it breaks each parse tree into constituents, calculates the count of each constituent, then applies the majority voting to decide which constituent would appear in the final tree.",
                    "sid": 33,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Sagae and Lavie (2006) improve this second scheme by introducing a threshold for the constituent count, and search for the tree with the largest number of count from all the possible constituent combination.",
                    "sid": 34,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Zeman and \u017dabokrtsk\u00fd (2005) study four combination techniques, including voting, stacking, unbalanced combining and switching, for constituent selection on Czech dependency parsing.",
                    "sid": 35,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Promising results have been reported in all the above three prior work.",
                    "sid": 36,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Henderson and Brill (1999) combine three parsers and obtained an F1 score of 90.6, which is better than the score of 88.6 obtained by the best individual parser as reported in their paper.",
                    "sid": 37,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Sagae and Lavie (2006) combine 5 parsers to obtain a score of 92.1, while they report a score of 91.0 for the best single parser in their paper.",
                    "sid": 38,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Finally, Zeman and \u017dabokrtsk\u00fd (2005) reports great improvements over each individual parsers and show that a parser with very low accuracy can also help to improve the performance of a highly accurate parser.",
                    "sid": 39,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, there are two major limitations in these prior works.",
                    "sid": 40,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "First, only one-best output from each individual parsers are utilized.",
                    "sid": 41,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Second, none of these works uses the parse probability of each parse tree output from the individual parser.",
                    "sid": 42,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Regarding the parser re-ranking, Collins (2000) proposes a dozen of feature types to re-rank kbest outputs of a single head-driven parser.",
                    "sid": 43,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "He uses these feature types to extract around half a million different features on the training set, and then examine two loss functions, MRF and Boosting, to do feature selection.",
                    "sid": 44,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Charniak and Johnson (2005) generate a more accurate k-best output and adopt MaxEnt method to estimate the feature weights for more than one million features extracted from the training set.",
                    "sid": 45,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Huang (2008) further improves the re-ranking work of Charniak and Johnson (2005) by re-ranking on packed forest, which could potentially incorporate exponential number of k-best list.",
                    "sid": 46,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The reranking techniques also achieve great improvement over the original individual parser.",
                    "sid": 47,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Collins (2002) improves the F1 score from 88.2% to 89.7%, while Charniak and Johnson (2005) improve from 90.3% to 91.4%.",
                    "sid": 48,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This latter work was then further improved by Huang (2008) to 91.7%, by utilizing the benefit of forest structure.",
                    "sid": 49,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, one of the limitations of these techniques is the huge number of features which makes the training very expensive and inefficient in space and memory usage.",
                    "sid": 50,
                    "ssid": 20,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "3 k-best combination of lexicalized and un-lexicalized parsers with model probabilities",
            "number": "3",
            "sents": [
                {
                    "text": "In this section, we first introduce our proposed kbest combination framework.",
                    "sid": 51,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Then we apply this framework to the combination of two state-ofthe-art lexicalized and un-lexicalized parsers with an additional feature inspired by traditional combination techniques.",
                    "sid": 52,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our proposed framework consists of the following steps: annotation model\u2019s confidence for this tree.",
                    "sid": 53,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This enables our method to effectively utilize the confidence measure of all the individual models without any bias.",
                    "sid": 54,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Without this re-evaluation step, the previous combination methods are unable to utilize the various model scores.",
                    "sid": 55,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The above is the linear function used in our method, where t is the tree to be evaluated, to are the model confidence scores (in this paper, we use logarithm of the parse tree probability) from the N models, to are their weights, \u2032 to \u2032 are the L additional features, \u2032 to \u2032 are their weights.",
                    "sid": 56,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper, we employ two individual parsing model scores and only one additional feature.",
                    "sid": 57,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let be the head-driven model score, be the latent-annotation model score, \u2032 be the constituent count feature and \u2032 is the weight of feature \u2032 .",
                    "sid": 58,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The term \u201cconfidence\u201d was used in prior parser combination studies to refer to the accuracy of each individual parser.",
                    "sid": 59,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This reflects how much we can trust the parse output of each parser.",
                    "sid": 60,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper, we use the term \u201cconfidence\u201d to refer to the logarithm of the tree probability computed by each model, which is a direct measurement of the model\u2019s confidence on the target tree being the best or correct parse output.",
                    "sid": 61,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In fact, the feature weight i in our linear model functions similarly as the traditional \u201cconfidence\u201d.",
                    "sid": 62,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, we do not directly use parser\u2019s accuracy as its value.",
                    "sid": 63,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Instead we tune it automatically on development set to optimize it against the parsing performance directly.",
                    "sid": 64,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the following, we introduce the state-of-the-art head-driven lexicalized and latent-annotation un-lexicalized models (which are used as two individual models in this paper), and describe how they compute the tree probability briefly.",
                    "sid": 65,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Head-driven model is one of the most representative lexicalized models.",
                    "sid": 66,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It attaches the head word to each non-terminal and views the generation of each rule as a Markov process first from father to head child, and then to the head child\u2019s left and right siblings.",
                    "sid": 67,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Take following rule r as example, is the rule\u2019s left hand side (i.e. father label), is the head child, is M\u2019s left sibling and is M\u2019s right sibling.",
                    "sid": 68,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let h be M\u2019s head word, the probability of this rule is The probability of a tree is just the product of the probabilities of all the rules in it.",
                    "sid": 69,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The above is the general framework of head-driven model.",
                    "sid": 70,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For a specific model, there may be some additional features and modification.",
                    "sid": 71,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, the model2 in Collins (1999) introduces subcategorization and model3 introduces gap as additional features.",
                    "sid": 72,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Charniak (2000)\u2019s model introduces pre-terminal as additional features.",
                    "sid": 73,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The latent-annotation model (Matsuzaki et al. 2005; Petrov et al.",
                    "sid": 74,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "2006) is one of the most effective un-lexicalized models.",
                    "sid": 75,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Briefly speaking, latent-annotation model views each non-terminal in the Treebank as a non-terminal followed by a set of latent variables, and uses EM algorithms to automatically learn the latent variables\u2019 probability functions to maximize the probability of the given training data.",
                    "sid": 76,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Take the following binarized rule as example, could be viewed as the set of rules The process of computing the probability of a normal tree is to first binarized all the rules in it, and then replace each rule to the corresponding set of rules with latent variables.",
                    "sid": 77,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Now the previous tree becomes a packed forest (Klein and Manning 2001; Petrov et al. 2007) in the latentannotation model, and its probability is the inside probability of the root node.",
                    "sid": 78,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This model is quite different from the head-driven model in which the probability of a tree is just the product all the rules\u2019 probability.",
                    "sid": 79,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Besides the two model scores, we also adopt constituent count as an additional feature inspired by (Henderson and Brill 1999) and (Sagae and Lavie 2006).",
                    "sid": 80,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A constituent is a non-terminal node covering a special span.",
                    "sid": 81,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, \u201cNP[2,4]\u201d means a constituent labelled as \u201cNP\u201d which covers the span from the second word to the fourth word.",
                    "sid": 82,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "If we have 100 trees and NP[2,4] appears in 60 of them, then its constituent count is 60.",
                    "sid": 83,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For each tree, its constituent count is the sum of all the counts of its constituent.",
                    "sid": 84,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, as suggested in (Sagae and Lavie 2006), this feature favours precision over recall.",
                    "sid": 85,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To solve this issue, Sagae and Lavie (2006) use a threshold to balance them.",
                    "sid": 86,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For any constituent, we calculate its count if and only if it appears more than X times in the k-best trees; otherwise we set it as 0.",
                    "sid": 87,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper, we normalize this feature by dividing the constituent count by the number of k-best.",
                    "sid": 88,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that the threshold value and the additional feature value are not independent.",
                    "sid": 89,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Once the threshold changes, the feature value has to be recalculated.",
                    "sid": 90,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In conclusion, we have four parameters to estimate: two model score weights, one additional feature weight and a threshold for the additional feature.",
                    "sid": 91,
                    "ssid": 41,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "4 parameter estimation",
            "number": "4",
            "sents": [
                {
                    "text": "We adopt the minimum error rate principle to tune the feature weights by minimizing the error rate (i.e. maximizing the F1 score) on the development set.",
                    "sid": 92,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In our study, we implement and compare two algorithms, the simulated-annealing style algorithm and the average perceptron algorithm.",
                    "sid": 93,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Simulated-annealing algorithm has been proved to be a powerful and efficient algorithm in solving NP problem (\u010cern\u00fd 1985).",
                    "sid": 94,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Fig 1 is the pseudo code of the simulated-annealing algorithm that we apply.",
                    "sid": 95,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In a single iteration (line 4-11), the simulated algorithm selects some random points (the Markov link) for hill climbing.",
                    "sid": 96,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, it accepts some bad points with a threshold probability controlled by the annealing temperature (line 710).",
                    "sid": 97,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The hill climbing nature gives this algorithm the ability of converging at local maximal point and the random nature offers it the chance to jump from some local maximal points to global maximal point.",
                    "sid": 98,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We do a slight modification to save the best parameter so far across all the finished iterations and let it be the initial point for upcoming iterations (line 12-17).",
                    "sid": 99,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "RandomNeighbour(p) is the function to generate a random neighbor for the p (the four-tuple parameter to be estimated).",
                    "sid": 100,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "F1(p) is the function to calculate the F1 score over the entire test set.",
                    "sid": 101,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given a fixed parameter p, it selects the candidate tree with best score for each sentence and computes the F1 score with the PARSEVAL metrics.",
                    "sid": 102,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Another algorithm we apply is the averaged perceptron algorithm.",
                    "sid": 103,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Fig 2 is the pseudo code of this algorithm.",
                    "sid": 104,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Averaged perceptron is an online algorithm.",
                    "sid": 105,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It iterates through each instance.",
                    "sid": 106,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In each instance, it selects the candidate answer with the maximum function score.",
                    "sid": 107,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Then it updates the weight by the margin of feature value between the select answer and the oracle answer (line 5-9).",
                    "sid": 108,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "After each iteration, it does average to generate a new weight (line 10).",
                    "sid": 109,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The averaged perceptron has a solid theoretical fundamental and was proved to be effective across a variety of NLP tasks (Collins 2002).",
                    "sid": 110,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, it needs a slightly modification to adapt to our problem.",
                    "sid": 111,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since the threshold and the constituent count are not independent, they are not linear separable.",
                    "sid": 112,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this case, the perceptron algorithm cannot be guaranteed to converge.",
                    "sid": 113,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To solve this issue, we introduce an outer loop (line 2) to iterate through the value range of threshold with a fixed step length and in the inner loop we use perceptron to estimate the other three parameters.",
                    "sid": 114,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Finally we select the final parameter which has maximum F1 score across all the iteration (line 14-17).",
                    "sid": 115,
                    "ssid": 24,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "5 experiments",
            "number": "5",
            "sents": [
                {
                    "text": "We evaluate our method on both Chinese and English syntactic parsing task with the standard division on Chinese Penn Treebank Version 5.0 and WSJ English Treebank 3.0 (Marcus et al. 1993) as shown in Table 1.",
                    "sid": 116,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We use Satoshi Sekine and Michael Collins\u2019 EVALB script modified by David Ellis for accuracy evaluation.",
                    "sid": 117,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We use Charniak\u2019s parser (Charniak 2000) and Berkeley\u2019s parser (Petrov and Klein 2007) as the two individual parsers, where Charniak\u2019s parser represents the best performance of the lexicalized model and the Berkeley\u2019s parser represents the best performance of the un-lexicalized model.",
                    "sid": 118,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We retrain both of them according to the division in Table.",
                    "sid": 119,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1.",
                    "sid": 120,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The number of EM iteration process for Berkeley\u2019s parser is set to 5 on English and 6 on Chinese.",
                    "sid": 121,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Both the Charniak\u2019s parser and Berkeley\u2019s parser provide function to evaluate an input parse tree\u2019s probability and output the logarithm of the probability.",
                    "sid": 122,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This sub-section examines the effectiveness of our proposed methods.",
                    "sid": 123,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The experiment is set up as follows: 1) for each sentence in the dev and test sets, we generate 50-best from Charniak\u2019s parser (Charniak 2000) and Berkeley\u2019s parser (Petrov and Klein 2007), respectively; 2) the two 50-best trees are merged together and duplication was removed; 3) we tune the parameters on the dev set and test on the test set.",
                    "sid": 124,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "(Without specific statement, we use simulated-annealing as default weight tuning algorithm.)",
                    "sid": 125,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The results are shown in Table 2 and Table 3.",
                    "sid": 126,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "\u201cP\u201d means precision, \u201cR\u201d means recall and \u201cF\u201d is the F1-measure (all is in % percentage metrics); \u201cCharniak\u201d represents the parser of (Charniak 2000), \u201cBerkeley\u201d represents the parser of (Petrov and Klein 2007), \u201cComb.\u201d represents the combination of the two parsers.",
                    "sid": 127,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "From Table 2 and Table 3, we can see our method outperforms the single systems in all test cases with all the three evaluation metrics.",
                    "sid": 128,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Using the entire Chinese test set, our method improves the performance by 2.3 (85.45-83.13) point in F1-Score, representing 13.8% error rate reduction.",
                    "sid": 129,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Using the entire English test set, our method improves the performance by 1.7 (91.43-89.70) point in F1-Score, representing 16.5% error rate reduction.",
                    "sid": 130,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These improvements convincingly demonstrate the effectiveness of our method.",
                    "sid": 131,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Fig 3 and Fig.",
                    "sid": 132,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "4 show the relationship between F1 score and the number of K-best used when doing combination on Chinese and English respectively.",
                    "sid": 133,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "From Fig 3 and Fig.",
                    "sid": 134,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "4, we could see that the F1 score first increases with the increasing of K (there are some vibration points, this may due to statistical noise) and reach the peak when K is around 30-50, then it starts to drop.",
                    "sid": 135,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It shows that k-best list did provide more information than one-best and thus can help improve the accuracy; however more k-best list may also contain more noises and these noises may hurt the final combination quality.",
                    "sid": 136,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this subsection, we examine how different of the 50-best trees generated from Charnriak\u2019s parser (head-driven model) (Charnriak, 2000) and Berkeley\u2019s parser (latent-annotation model) (Petrov and Klein, 2007).",
                    "sid": 137,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 4 reports the statistics on the 50-best output for Chinese and English test set.",
                    "sid": 138,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since for some short sentences the parser cannot generate up to 50 best trees, the average number of trees is less than 50 for each sentence.",
                    "sid": 139,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each cell reports the total number of trees generated over the entire test set followed by the average count for each sentence in bracket.",
                    "sid": 140,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "\u201cTotal\u201d means simply combine the number of trees from the two parsers while \u201cUnique\u201d means the number after removing the duplicated trees for each sentence.",
                    "sid": 141,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the last row, we report the averaged redundant rate for each sentence, which is derived by dividing the figures in the row \u201cDuplicated\u201d by those in the row \u201cTotal\u201d.",
                    "sid": 142,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The small redundant rate clearly suggests that the two parsing models are quite different and are complementary to each other.",
                    "sid": 143,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The k-best oracle score is the upper bound of the quality of the k-best trees.",
                    "sid": 144,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 5 reports the oracle score for the 50-best of the two individual parsers and our method.",
                    "sid": 145,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Similar to Table 4, Table 5 shows again that the two models are complementary to each other and our method is able to take the strength of the two models.",
                    "sid": 146,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "One of the advantages of our method that we claim is that we can utilize the feature of the model confidence score (logarithm of the parse tree probability).",
                    "sid": 147,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 6 shows that all the three features contribute to the final accuracy improvement.",
                    "sid": 148,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Even if we only use the \u201cB+C\u201d confidence scores, it also outperforms the baseline individual parser (as reported in Table 2 and Table 3) greatly.",
                    "sid": 149,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "All these together clearly verify the effective of the model confidence feature and our method can effectively utilize this feature.",
                    "sid": 150,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Feat.",
                    "sid": 151,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "I B+C B+C+I Lang Chinese 82.34 84.67 85.45 English 90.20 91.02 91.43 Table 6.",
                    "sid": 152,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "F1 score on 50-best combination with different feature configuration.",
                    "sid": 153,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "\u201cI\u201d means the constituent count, \u201cB\u201d means Berkeley parser confidence score and \u201cC\u201d means Charniak parser confidence score.",
                    "sid": 154,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this sub-section, we compare the two weight tuning algorithms on 50-best combination tasks on both Chinese and English.",
                    "sid": 155,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Dan Bikel\u2019s randomized parsing evaluation comparator (Bikel 2004) was used to do significant test on precision and recall metrics.",
                    "sid": 156,
                    "ssid": 41,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The results are shown in Table 7.",
                    "sid": 157,
                    "ssid": 42,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We can see, simulated annealing outperforms the averaged perceptron significantly in both precision (p<0.005) and recall (p<0.05) metrics of Chinese task and precision (p<0.005) metric of English task.",
                    "sid": 158,
                    "ssid": 43,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Though averaged perceptron got slightly better recall score on English task, it is not significant according to the p-value (p>0.2).",
                    "sid": 159,
                    "ssid": 44,
                    "kind_of_tag": "s"
                },
                {
                    "text": "From table 8, we could see the simulated annealing algorithm is around 2-4 times slower than averaged perceptron algorithm.",
                    "sid": 160,
                    "ssid": 45,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "5.6 performance-enhanced individual parsers on english",
            "number": "6",
            "sents": [
                {
                    "text": "For Charniak\u2019s lexicalized parser, there are two techniques to improve its performance.",
                    "sid": 161,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "One is reranking as explained in section 2.",
                    "sid": 162,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The other is the self-training (McClosky et al. 2006) which first parses and reranks the NANC corpus, and then use them as additional training data to retrain the model.",
                    "sid": 163,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this sub-section, we apply our method to combine the Berkeley parser and the enhanced Charniak parser by using the new model confidence score output from the enhanced Charniak parser.",
                    "sid": 164,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 9 and Table 10 show that the Charniak parser enhanced by re-ranking and self-training is able to help to further improve the performance of our method.",
                    "sid": 165,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is because that the enhanced Charniak parser provides more accurate model confidence score.",
                    "sid": 166,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 11 and table 12 compare our method with the other state-of-the-art methods; we use I, B, R, S and C to denote individual model (Charniak 2000; Collins 2000; Bod 2003; Petrov and Klein 2007), bilingual-constrained model (Burkett and Klein 2008)1, re-ranking model (Charniak and Johnson 2005, Huang 2008), self-training model (David McClosky 2006) and combination model (Sagae and Lavie 2006) respectively.",
                    "sid": 167,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The two tables clearly show that our method advance the state-of-the-art results on both Chinese and English syntax parsing.",
                    "sid": 168,
                    "ssid": 8,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "6 conclusions",
            "number": "7",
            "sents": [
                {
                    "text": "In this paper, we propose a linear model-based general framework for multiple parser combination.",
                    "sid": 169,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Compared with previous methods, our method is able to use diverse features, including logarithm of the parse tree probability calculated by the individual systems.",
                    "sid": 170,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We verify our method by combining the two representative parsing models, lexicalized model and un-lexicalized model, on both Chinese and English.",
                    "sid": 171,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Experimental results show our method is very effective and advance the state-of-the-art results on both Chinese and English syntax parsing.",
                    "sid": 172,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the future, we will explore more features and study the forest-based combination methods for syntactic parsing.",
                    "sid": 173,
                    "ssid": 5,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "acknowledgement",
            "number": "8",
            "sents": [
                {
                    "text": "We would like to thank Prof. Hwee Tou Ng for his help and support; Prof. Charniak for his suggestion on doing the experiments with the selftrained parser and David McCloksy for his help on the self-trained model; Yee Seng Chan and the anonymous reviewers for their valuable comments.",
                    "sid": 174,
                    "ssid": 1,
                    "kind_of_tag": "s"
                }
            ]
        }
    ]
}