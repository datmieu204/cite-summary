{
    "ID": "N09-1061",
    "sections": [
        {
            "text": "abstract",
            "number": 0,
            "sents": [
                {
                    "text": "Optimal Reduction of Rule Length in Linear Context-Free Rewriting Systems",
                    "sid": 0,
                    "ssid": null,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Linear Context-free Rewriting Systems (LCFRS) is an expressive grammar formalism with applications in syntax-based machine translation.",
                    "sid": 1,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The parsing complexity of an is exponential in both the of a production, defined as the number of nonterminals on its right-hand side, and a measure for the discontinuity of a phrase, In this paper, we present an algorithm that transforms an LCFRS into a strongly equivalent form in which productions have rank at most and has minimal fan-out.",
                    "sid": 2,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our results generalize previous work on Synchronous Context-Free Grammar, and are particularly relevant for machine translation from or to languages that require syntactic analyses with discontinuous constituents.",
                    "sid": 3,
                    "ssid": 3,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "1 introduction",
            "number": "1",
            "sents": [
                {
                    "text": "There is currently considerable interest in syntaxbased models for statistical machine translation that are based on the extraction of a synchronous grammar from a corpus of word-aligned parallel texts; see for instance Chiang (2007) and the references therein.",
                    "sid": 4,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "One practical problem with this approach, apart from the sheer number of the rules that result from the extraction procedure, is that the parsing complexity of all synchronous formalisms that we are aware of is exponential in the rank of a rule, defined as the number of nonterminals on the righthand side.",
                    "sid": 5,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore, it is important that the rules of the extracted grammar are transformed so as to minimise this quantity.",
                    "sid": 6,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Not only is this beneficial in terms of parsing complexity, but smaller rules can also improve a translation model\u2019s ability to generalize to new data (Zhang et al., 2006).",
                    "sid": 7,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Optimal algorithms exist for minimising the size of rules in a Synchronous Context-Free Grammar (SCFG) (Uno and Yagiura, 2000; Zhang et al., 2008).",
                    "sid": 8,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the SCFG formalism is limited to modelling word-to-word alignments in which a single continuous phrase in the source language is aligned with a single continuous phrase in the target language; as defined below, this amounts to saying that SCFG have a fan-out of 2.",
                    "sid": 9,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This restriction appears to render SCFG empirically inadequate.",
                    "sid": 10,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In particular, Wellington et al. (2006) find that the coverage of a translation model can increase dramatically when one allows a bilingual phrase to stretch out over three rather than two continuous substrings.",
                    "sid": 11,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This observation is in line with empirical studies in the context of dependency parsing, where the need for formalisms with higher fan-out has been observed even in standard, single language texts (Kuhlmann and Nivre, 2006).",
                    "sid": 12,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper, we present an algorithm that computes optimal decompositions of rules in the formalism of Linear Context-Free Rewriting Systems (LCFRS) (Vijay-Shanker et al., 1987).",
                    "sid": 13,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "LCFRS was originally introduced as a generalization of several so-called mildly context-sensitive grammar formalisms.",
                    "sid": 14,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the context of machine translation, LCFRS is an interesting generalization of SCFG because it does not restrict the fan-out to 2, allowing productions with arbitrary fan-out (and arbitrary rank).",
                    "sid": 15,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given an LCFRS, our algorithm computes a strongly equivalent grammar with rank 2 and minimal increase in fan-out.1 In this context, strong equivalence means that the derivations of the original grammar can be reconstructed using some simple homomorphism (c.f.",
                    "sid": 16,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Nijholt, 1980).",
                    "sid": 17,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our contribution is significant because the existing algorithms for decomposing SCFG, based on Uno and Yagiura (2000), cannot be applied to LCFRS, as they rely on the crucial property that components of biphrases are strictly separated in the generated string: Given a pair of synchronized nonterminal symbols, the material derived from the source nonterminal must precede the material derived from the target nonterminal, or vice versa.",
                    "sid": 18,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The problem that we solve has been previously addressed by Melamed et al. (2004), but in contrast to our result, their algorithm does not guarantee an optimal (minimal) increase in the fanout of the resulting grammar.",
                    "sid": 19,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, this is essential for the practical applicability of the transformed grammar, as the parsing complexity of LCFRS is exponential in both the rank and the fan-out.",
                    "sid": 20,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Structure of the paper The remainder of the paper is structured as follows.",
                    "sid": 21,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Section 2 introduces the terminology and notation that we use for LCFRS.",
                    "sid": 22,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In Section 3, we present the technical background of our algorithm; the algorithm itself is discussed in Section 4.",
                    "sid": 23,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Section 5 concludes the paper by discussing related work and open problems.",
                    "sid": 24,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "General notation The set of non-negative integers is denoted by N. For i, j \u2208 N, we write [i, j] to denote the interval { k \u2208 N  |i \u2264 k \u2264 j }, and use [i] as a shorthand for [1, i].",
                    "sid": 25,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given an alphabet V , we write V * for the set of all (finite) strings over V .",
                    "sid": 26,
                    "ssid": 23,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "2 preliminaries",
            "number": "2",
            "sents": [
                {
                    "text": "We briefly summarize the terminology and notation that we adopt for LCFRS; for detailed definitions, see Vijay-Shanker et al. (1987).",
                    "sid": 27,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let V be an alphabet.",
                    "sid": 28,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For natural numbers r \u2265 0 and f, f1, ... , fr \u2265 1, a function is called a linear, non-erasing function over V of type f1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 fr \u2192 f, if it can be defined by an equation of the form where Qg = h\u03b1g,1, ... , \u03b1g,fi is an f-tuple of strings over the variables on the left-hand side of the equation and symbols in V that contains exactly one occurrence of each variable.",
                    "sid": 29,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We call the value r the rank of g, the value f its fan-out, and write \u03c1(g) and co(g), respectively, to denote these quantities.",
                    "sid": 30,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that, if we assume the variables on the lefthand side of the defining equation of g to be named according to the specific schema given above, then g is uniquely determined by Qg.",
                    "sid": 31,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A linear context-free rewriting system (LCFRS) is a construct G = (VN, VT, P, 5), where: VN is an alphabet of nonterminal symbols in which each symbol A \u2208 VN is associated with a value co(A), called its fan-out; VT is an alphabet of terminal symbols; 5 \u2208 N is a distinguished start symbol with co(5) = 1; and P is a set of productions of the form where A, B1, ... , Br \u2208 VN, and g is a linear, nonerasing function over the terminal alphabet VT of type co(B1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 co(Br) \u2192 co(A).",
                    "sid": 32,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In a derivation of an LCFRS, the production p can be used to transform a sequence of r tuples of strings, generated by the nonterminals B1, ... , Br, into a single co(A)-tuple of strings, associated with the nonterminal A.",
                    "sid": 33,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The values \u03c1(g) and co(g) are called the rank and fan-out of p, respectively, and we write \u03c1(p) and co(p), respectively, to denote these quantities.",
                    "sid": 34,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The rank and fan-out of G, written \u03c1(G) and co(G), respectively, are the maximum rank and fan-out among all of its productions.",
                    "sid": 35,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given that co(5) = 1, a derivation will associate 5 with a set of one-component tuples of strings over VT; this forms the string language generated by G. Example 1 The following LCFRS generates the string language { anbncndn  |n \u2208 N}.",
                    "sid": 36,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We only specify the set of productions; the remaining components of the grammar are obvious from that.",
                    "sid": 37,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The functions g1 and g2 have rank 1; the function g3 has rank 0.",
                    "sid": 38,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The functions g2 and g3 have fan-out 2; the function g1 has fan-out 1.",
                    "sid": 39,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "\u2751",
                    "sid": 40,
                    "ssid": 14,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "3 technical background",
            "number": "3",
            "sents": [
                {
                    "text": "The general idea behind our algorithm is to replace each production of an LCFRS with a set of \u201cshorter\u201d productions that jointly are equivalent to the original production.",
                    "sid": 41,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Before formalizing this idea, we first introduce a specialized representation for the productions of an LCFRS.",
                    "sid": 42,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We distinguish between occurrences of symbols within a string by exploiting two different notations.",
                    "sid": 43,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let \u03b1 = a1a2 \u00b7 \u00b7 \u00b7 an be a string.",
                    "sid": 44,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The occurrence ai in \u03b1 can be denoted by means of its position index i \u2208 [n], or else by means of its two (left and right) endpoints, i \u22121 and i; here, the left (right) endpoint denotes a boundary between occurrence ai and the previous (subsequent) occurrence, or the beginning (end) of the string \u03b1.",
                    "sid": 45,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Similarly, a substring ai \u00b7 \u00b7 \u00b7 aj of \u03b1 with i \u2264 j can be denoted by the positions i, i + 1, ... , j of its occurrences, or else by means of its left and right endpoints, i \u2212 1 and j.",
                    "sid": 46,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For the remainder of this section, let us fix an Let $ be a fresh symbol that does not occur in G. We define the characteristic string of the production p as and the variable string of p as the string \u03c3N(p) obtained from \u03c3(p) by removing all the occurrences of symbols in VT.",
                    "sid": 47,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Example 2 We will illustrate the concepts introduced in this section using the concrete production Let I be an index set, I \u2286 [r].",
                    "sid": 48,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Consider the set B of occurrences Bi in the right-hand side of p such that i \u2208 I.2 We define the position set of B, denoted by \u03a0B, as the set of all positions 1 \u2264 j \u2264 |\u03c3N(p)| such that the jth symbol in \u03c3N(p) is a variable of the form xi,h, for i \u2208 I and some h \u2265 1.",
                    "sid": 49,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Example 3 Some position sets of p0 are A position set \u03a0B can be uniquely expressed as the union of f \u2265 1 intervals [l1 + 1, r1], ... , [lf + 1, rf] such that ri\u22121 < li for every 1 < i \u2264 f. Thus we define the set of endpoints of \u03a0B as The quantity f is called the fan-out of \u03a0B, written \u03d5(\u03a0B).",
                    "sid": 50,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Notice that the fan-out of a position set \u03a0{B} does not necessarily coincide with the fan-out of the non-terminal B in the underlying LCFRS.",
                    "sid": 51,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A set with 2f endpoints always corresponds to a position set of fan-out f. Example 4 For our running example, we have \u0394{B1} = {0,1, 2, 3}, \u0394{B2} = {1, 2}, \u0394{B3} = {4, 6}.",
                    "sid": 52,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Consequently, the fan-out of \u0394{B1} is 2, and the fan-out of \u0394{B2} and \u0394{B3} is 1.",
                    "sid": 53,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Notice that the fan-out of the non-terminal B3 is 2.",
                    "sid": 54,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "\u2751 We drop B from \u03a0B and \u0394B whenever this set is understood from the context or it is not relevant.",
                    "sid": 55,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given a set of endpoints \u0394 = {i1,... , i2f} with i1 < \u00b7 \u00b7 \u00b7 < i2f, we obtain its corresponding position set by calculating the closure of \u0394, defined as 2To avoid clutter in our examples, we abuse the notation by not making an explicit distinction between nonterminals and occurrences of nonterminals in productions.",
                    "sid": 56,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Assume that r > 2.",
                    "sid": 57,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The reduction of p by the nonterminal occurrences Br\u22121, Br is the ordered pair of productions (p1, p2) that is defined as follows.",
                    "sid": 58,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let \u03b31, ... ,\u03b3n be the maximal substrings of \u03c3(p) that contain only variables xi,j with r\u2014 1 G i G r and terminal symbols, and at least one variable.",
                    "sid": 59,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Then where X is a fresh nonterminal symbol, the characteristic string \u03c3(p1) is the string obtained from \u03c3(p) by replacing each substring \u03b3i by the variable xr\u22121,i, and the characteristic string \u03c3(p2) is the string \u03b31$ \u00b7\u00b7\u00b7 $\u03b3n.",
                    "sid": 60,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that the defining equations of neither g1 nor g2 are in the specific form discussed in Section 2.1; however, they can be brought into this form by a consistent renaming of the variables.",
                    "sid": 61,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will silently assume this renaming to take place.",
                    "sid": 62,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Example 5 The reduction of p0 by the nonterminal occurrences B2 and B3 has p1 : A \u2014* g1(B1, X) and p2 : X \u2014* g2(B2, B3) with or, after renaming and in standard notation, It is easy to check that a reduction provides us with a pair of productions that are equivalent to the original production p, in terms of generative capacity, since for all tuples of strings generated from the nonterminals B1, ... , Br, respectively.",
                    "sid": 63,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note also that the fanout of production p1 equals the fan-out of p. However, the fan-out of p2 (the value n) may be greater than the fan-out of p, depending on the way variables are arranged in \u03c3(p).",
                    "sid": 64,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Thus, a reduction does not necessarily preserve the fan-out of the original production.",
                    "sid": 65,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the worst case, the fan-out of p2 can be as large as \u03d5(Br\u22121) + \u03d5(Br).",
                    "sid": 66,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We have defined reductions only for the last two occurrences of nonterminals in the right-hand side of a production p. However, it is easy to see that we can also define the concept for two arbitrary (not necessarily adjacent) occurrences of nonterminals, at the cost of making the notation more complicated.",
                    "sid": 67,
                    "ssid": 27,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "4 the algorithm",
            "number": "4",
            "sents": [
                {
                    "text": "Let G be an LCFRS with \u03d5(G) = f and \u03c1(G) = r, and let f0 > f be a target fan-out.",
                    "sid": 68,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will now present an algorithm that computes an equivalent LCFRS G0 of fan-out at most f0 whose rank is at most 2, if such an LCFRS exists in the first place.",
                    "sid": 69,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The algorithm works by exhaustively reducing all productions in G. Given an LCFRS production p, a naive algorithm to compute an equivalent set of productions whose rank is at most 2 is given in Figure 1.",
                    "sid": 70,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By applying this algorithm to all the productions in the LCFRS G, we can obtain an equivalent LCFRS with rank 2.",
                    "sid": 71,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will call such an LCFRS a binarization of G. The fan-out of the obtained LCFRS will depend on the nonterminals that we choose for the reductions in line 5.",
                    "sid": 72,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It is not difficult to see that, in the worst case, the resulting fan-out can be as high as Fr2] \u00b7 f. This occurs when we choose Fr2] nonterminals with fan-out f that have associated variables in the string \u03c3N(p) that do not occur at consecutive positions.",
                    "sid": 73,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The algorithm that we develop in Section 4.3 improves on the naive algorithm in that it can be exploited to find a sequence of reductions that results in a binarization of G that is optimal, i.e., leads to an LCFRS with minimal fan-out.",
                    "sid": 74,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The algorithm is based on a technical concept called adjacency.",
                    "sid": 75,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let p be some production in the LCFRS G, and let \u03941, \u03942 be sets of endpoints, associated with some sets of nonterminal occurrences in p. We say that \u03941 and \u03942 overlap if the intersection of their closures is nonempty, that is, if [\u03941]\u2229[\u03942] =6 \u2205.",
                    "sid": 76,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Overlapping holds if and only if the associated sets of nonterminal occurrences are not disjoint.",
                    "sid": 77,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "If \u03941 and \u03942 do not overlap, we define their merge as It is easy to see that [\u2295(\u03941, \u03942)] = [\u03941] \u222a [\u03942].",
                    "sid": 78,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We say that \u03941 and \u03942 are adjacent for a given fanout f, written \u03941 \u2194f \u03942, if \u03941 and \u03942 do not overlap, and co([\u2295(\u03941, \u03942)]) \u2264 f. Example 6 For the production p0 from Example 2, we have \u2295(\u0394{B1}, \u0394{B2}) = {0, 3}, showing that \u0394{B1} \u21941 \u0394{B2}.",
                    "sid": 79,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Similarly, we have \u2295(\u0394{B1}, \u0394{B3}) = {0, 1, 2, 3, 4, 6} , showing that \u0394{B1} \u21943 \u0394{B3}, but that neither \u0394{B1} \u21942 \u0394{B3} nor \u0394{B1} \u21941 \u0394{B3} holds.",
                    "sid": 80,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "\u2737 The adjacency-based binarization algorithm is given in Figure 2.",
                    "sid": 81,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It starts with a working set containing the endpoint sets corresponding to each nonterminal occurrence in the input production p. Reductions of p are only explored for nonterminal occurrences whose endpoint sets are adjacent for the target fan-out f0, since reductions not meeting this constraint would produce productions with fan-out greater than f0.",
                    "sid": 82,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each reduction explored by the algorithm produces a new endpoint set, associated to the fresh nonterminal that it introduces, and this new endpoint set is added to the working set and potentially used in further reductions.",
                    "sid": 83,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "From the definition of the adjacency relation \u2194f, it follows that at lines 9 and 10 of BOUNDEDBINARIZATION we only pick up reductions for p that do not exceed the fan-out bound of f0.",
                    "sid": 84,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This implies soundness for our algorithm.",
                    "sid": 85,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Completeness means that the algorithm fails only if there exists no binarization for p of fan-out not greater than f0.",
                    "sid": 86,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This property is intuitive if one observes that our algorithm is a specialization of standard algorithms for the computation of the closure of binary relations.",
                    "sid": 87,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A formal proof of this fact is rather long and tedious, and will not be reported here.",
                    "sid": 88,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We notice that there is a very close similarity between algorithm BOUNDED-BINARIZATION and the deduction procedure proposed by Shieber et al. (1995) for parsing.",
                    "sid": 89,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We discuss this more at length in Section 5.",
                    "sid": 90,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that we have expressed the algorithm as a decision function that will return true if there exists a binarization of p with fan-out not greater than f0, and false otherwise.",
                    "sid": 91,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the algorithm can easily be modified to return a reduction producing such a binarization, by adding to each endpoint set \u0394 \u2208 workingSet two pointers to the adjacent endpoint sets that were used to obtain it.",
                    "sid": 92,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "If the algorithm is successful, the tree obtained by following these pointers from the final endpoint set \u0394{B1,...,B\u03c1(p)} \u2208 workingSet gives us a tree of reductions that will produce a binarization of p with fan-out not greater than f0, where each node labeled with the set \u0394{Bi} corresponds to the nonterminal BZ, and nodes labeled with other endpoint sets correspond to the fresh nonterminals created by the reductions.",
                    "sid": 93,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In order to implement BOUNDED-BINARIZATION, we can represent endpoint sets in a canonical way as 2f0-tuples of integer positions in ascending order, and with some special null value used to fill positions for endpoint sets with fan-out strictly smaller than f0.",
                    "sid": 94,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will assume that the concrete null value is larger than any other integer.",
                    "sid": 95,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We also need to provide some appropriate representation for the set workingSet, in order to guarantee efficient performance for the membership test and the insertion operation.",
                    "sid": 96,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Both operations can be implemented in constant time if we represent workingSet as an (2\u00d7f0)-dimensional table with Boolean entries.",
                    "sid": 97,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each dimension is indexed by values in [0, n] plus our special null value; here n is the length of the string \u03c3N(p), and thus n = O(|p|).",
                    "sid": 98,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, this has the disadvantage of using space \u0398(n2f0), even in case workingSet is sparse, and is affordable only for quite small values of f0.",
                    "sid": 99,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Alternatively, we can more compactly represent workingSet as a trie data structure.",
                    "sid": 100,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This representation has size certainly smaller than 2f0 \u00d7 q, where q is the size of the set workingSet.",
                    "sid": 101,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, both membership and insertion operations take now an amount of time O(2f0).",
                    "sid": 102,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We now analyse the time complexity of algorithm BOUNDED-BINARIZATION for inputs p and f0.",
                    "sid": 103,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We first focus on the while-loop at lines 7 to 13.",
                    "sid": 104,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As already observed, the number of possible endpoint sets is bounded by O(n2f0).",
                    "sid": 105,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Furthermore, because of the test at line 11, no endpoint set is ever inserted into the agenda variable more than once in a single run of the algorithm.",
                    "sid": 106,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We then conclude that our while-loop cycles a number of times O(n2f0).",
                    "sid": 107,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We now focus on the choice of the endpoint set \u03941 in the inner for-loop at lines 9 to 13.",
                    "sid": 108,
                    "ssid": 41,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let us fix \u0394 as in line 8.",
                    "sid": 109,
                    "ssid": 42,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It is not difficult to see that any \u03941 with This means that, for each \u0394 coming out of the agenda, at line 9 we can choose all endpoint sets \u03941 such that \u03941 \u2194f0 \u0394 by performing the following steps: We claim that, in the above steps, the number of involved endpoints does not exceed 3f0.",
                    "sid": 110,
                    "ssid": 43,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To see this, we observe that from (2) we can derive |I |\u2265 \u03d5(\u0394) + \u03d5(\u03941) \u2212 f0.",
                    "sid": 111,
                    "ssid": 44,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The total number of (distinct) endpoints in a single iteration step is as claimed.",
                    "sid": 112,
                    "ssid": 45,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since each endpoint takes values in the set [0, n], we have a total of O(n3f0) different choices.",
                    "sid": 113,
                    "ssid": 46,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For each such choice, we need to classify an endpoint as belonging to either \u0394\\I, \u03941\\I, or I.",
                    "sid": 114,
                    "ssid": 47,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This amounts to an additional O(33f0) different choices.",
                    "sid": 115,
                    "ssid": 48,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Overall, we have a total number of O((3n)3f0) different choices.",
                    "sid": 116,
                    "ssid": 49,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For each such choice, the test for membership in workingSet for \u03941 takes constant time in case we use a multi-dimensional table, or else O(|p|) in case we use a trie.",
                    "sid": 117,
                    "ssid": 50,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The adjacency test and the merge operations can easily be carried out in time O(|p|).",
                    "sid": 118,
                    "ssid": 51,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Putting all of the above observations together, and using the already observed fact that n = O(|p|), we can conclude that the total amount of time required by the while-loop at lines 7 to 13 is bounded by O(|p |\u00b7 (3|p|)3f0), both under the assumption that workingSet is represented as a multi-dimensional table or as a trie.",
                    "sid": 119,
                    "ssid": 52,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is also a bound on the running time of the whole algorithm.",
                    "sid": 120,
                    "ssid": 53,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The algorithm defined in Section 4.3 can be used to binarize an LCFRS in such a way that each rule in the resulting binarization has the minimum possible fan-out.",
                    "sid": 121,
                    "ssid": 54,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This can be done by applying the BOUNDED-BINARIZATION algorithm to each production p, until we find the minimum value for the bound f' for which this algorithm finds a binarization.",
                    "sid": 122,
                    "ssid": 55,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For a production with rank r and fan-out f, we know that this optimal value of f' must be in the interval [f, Fr2] \u00b7 f] because binarizing a production cannot reduce its fan-out, and the NAIVEBINARIZATION algorithm seen in Section 4.1 can binarize any production by increasing fan-out to Fr] \u00b7 f in the worst case.",
                    "sid": 123,
                    "ssid": 56,
                    "kind_of_tag": "s"
                },
                {
                    "text": "2 The simplest way of finding out the optimal value of f' for each production is by a sequential search starting with co(p) and going upwards, as in the algorithm in Figure 3.",
                    "sid": 124,
                    "ssid": 57,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that the upper bound Fr2] \u00b7 f that we have given for f' guarantees that the whileloop in this algorithm always terminates.",
                    "sid": 125,
                    "ssid": 58,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the worst case, we may need f \u00b7 (Fr2] \u2212 1) + 1 executions of the BOUNDED-BINARIZATION algorithm to find the optimal binarization of a production in G. This complexity can be reduced by changing the strategy to search for the optimal f': for example, we can perform a binary search within the interval [f, Fr2] \u00b7 f], rization in Llog(f \u00b7(Fr2]\u22121)+1)]+1 executions of BOUNDED-BINARIZATION.",
                    "sid": 126,
                    "ssid": 59,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, this will not result in a practical improvement, since BOUNDEDBINARIZATION is exponential in the value of f' and the binary search will require us to run it on values of f' larger than the optimal in most cases.",
                    "sid": 127,
                    "ssid": 60,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An intermediate strategy between the two is to apply exponential backoff to try the sequence of values f \u22121+2i (for i = 0, 1, 2 ...).",
                    "sid": 128,
                    "ssid": 61,
                    "kind_of_tag": "s"
                },
                {
                    "text": "When we find the first i such that BOUNDED-BINARIZATION does not fail, if i > 0, we apply the same strategy to the interval [f\u22121+2i\u22121, f\u22122+2i], and we repeat this method to shrink the interval until BOUNDED-BINARIZATION does not fail for i = 0, giving us our optimal f'.",
                    "sid": 129,
                    "ssid": 62,
                    "kind_of_tag": "s"
                },
                {
                    "text": "With this strategy, the amount of executions of the algorithm that we need in the worst case is where w = f \u00b7 (Fr2] \u2212 1) + 1, but we avoid using unnecessarily large values of f'.",
                    "sid": 130,
                    "ssid": 63,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "5 discussion",
            "number": "5",
            "sents": [
                {
                    "text": "To conclude this paper, we now discuss a number of aspects of the results that we have presented, including various other pieces of research that are particularly relevant to this paper.",
                    "sid": 131,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The algorithm introduced in this paper can be used to transform an LCFRS into an equivalent form with rank 2.",
                    "sid": 132,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This will result into a more efficiently parsable LCFRS, since rank exponentially affects parsing complexity.",
                    "sid": 133,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, we must take into account that parsing complexity is also influenced by fan-out.",
                    "sid": 134,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our algorithm guarantees a minimal increase in fan-out.",
                    "sid": 135,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In practical cases it seems such an increase is quite small.",
                    "sid": 136,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, in the context of dependency parsing, both G\u00b4omezRodr\u00b4\u0131guez et al. (2009) and Kuhlmann and Satta (2009) show that all the structures in several wellknown non-projective dependency treebanks are binarizable without any increase in their fan-out.",
                    "sid": 137,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "More in general, it has been shown by Seki et al. (1991) that parsing of LCFRS can be carried out in time 0(n|pM|), where n is the length of the input string and pM is the production in the grammar with largest size.3 Thus, there may be cases in which one has to find an optimal tradeoff between rank and fanout, in order to minimize the size of pM.",
                    "sid": 138,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This requires some kind of Viterbi search over the space of all possible binarizations, constructed as described at the end of Subsection 4.3, for some appropriate value of the fan-out f'.",
                    "sid": 139,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This paper has focussed on string-based LCFRS.",
                    "sid": 140,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As discussed in Vijay-Shanker et al. (1987), LCFRS provide a more general framework where the productions are viewed as generating a set of abstract derivation trees.",
                    "sid": 141,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These trees can be used to specify how structures other than tuples of strings are composed.",
                    "sid": 142,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, LCFRS derivation trees can be used to specify how the elementary trees of a Tree Adjoining Grammar can be composed to produced derived tree.",
                    "sid": 143,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the results in this paper also apply to non-string-based LCFRS, since by limiting attention to the terminal string yield of whatever structures are under consideration, the composition operations can be defined using the string-based version of LCFRS that is discussed here.",
                    "sid": 144,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The NAIVE-BINARIZATION algorithm given in Figure 1 is not novel to this paper: it is similar to an algorithm developed in Melamed et al. (2004) for generalized multitext grammars, a formalism weakly equivalent to LCFRS that has been introduced for syntax-based machine translation.",
                    "sid": 145,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the grammar produced by our algorithm has optimal (minimal) fan-out.",
                    "sid": 146,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is an important improvement over the result in (Melamed et al., 2004), as this quantity enters into the parsing complexity of both multitext grammars and LCFRS as an exponential factor, and therefore must be kept as low as possible to ensure practically viable parsing.",
                    "sid": 147,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Rank reduction is also investigated in Nesson et al. (2008) for synchronous tree-adjoining grammars, a synchronous rewriting formalism based on tree-adjoining grammars Joshi and Schabes (1992).",
                    "sid": 148,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this case the search space of possible reductions is strongly restricted by the tree structures specified by the formalism, resulting in simplified computation for the reduction algorithms.",
                    "sid": 149,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This feature is not present in the case of LCFRS.",
                    "sid": 150,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "There is a close parallel between the technique used in the MINIMAL-BINARIZATION algorithm and deductive parsing techniques as proposed by Shieber et al. (1995), that are usually implemented by means of tabular methods.",
                    "sid": 151,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The idea of exploiting tabular parsing in production factorization was first expressed in Zhang et al. (2006).",
                    "sid": 152,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In fact, the particular approach presented here has been used to improve efficiency of parsing algorithms that use discontinuous syntactic models, in particular, nonprojective dependency grammars, as discussed in G\u00b4omez-Rodr\u00b4\u0131guez et al. (2009).",
                    "sid": 153,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The bounded binarization algorithm that we have presented has exponential run-time in the value of the input fan-out bound f'.",
                    "sid": 154,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It remains an open question whether the bounded binarization problem for LCFRS can be solved in deterministic polynomial time.",
                    "sid": 155,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Even in the restricted case of f' = cp(p), that is, when no increase in the fan-out of the input production is allowed, we do not know whether p can be binarized using only deterministic polynomial time in the value of p\u2019s fan-out.",
                    "sid": 156,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, our bounded binarization algorithm shows that the latter problem can be solved in polynomial time when the fan-out of the input LCFRS is bounded by some constant.",
                    "sid": 157,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Whether the bounded binarization problem can be solved in polynomial time in the value of the input bound f' is also an open problem in the restricted case of synchronous context-free grammars, a special case of an LCFRS of fan-out two with a strict separation between the two components of each nonterminal in the right-hand side of a production, as discussed in the introduction.",
                    "sid": 158,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An interesting analysis of this restricted problem can be found in Gildea and Stefankovic (2007).",
                    "sid": 159,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Acknowledgements The work of Carlos G\u00b4omezRodr\u00b4\u0131guez was funded by Ministerio de Educaci\u00b4on y Ciencia and FEDER (HUM2007-66607-C04) and Xunta de Galicia (PGIDIT07SIN005206PR, INCITE08E1R104022ES, INCITE08ENA305025ES, INCITE08PXIB302179PR and Rede Galega de Procesamento da Linguaxe e Recuperaci\u00b4on de Informaci\u00b4on).",
                    "sid": 160,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The work of Marco Kuhlmann was funded by the Swedish Research Council.",
                    "sid": 161,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The work of Giorgio Satta was supported by MIUR under project PRIN No.",
                    "sid": 162,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "2007TJNZRE 002.",
                    "sid": 163,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We are grateful to an anonymous reviewer for a very detailed review with a number of particularly useful suggestions.",
                    "sid": 164,
                    "ssid": 34,
                    "kind_of_tag": "s"
                }
            ]
        }
    ]
}