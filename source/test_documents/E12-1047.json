{
    "ID": "E12-1047",
    "sections": [
        {
            "text": "abstract",
            "number": 0,
            "sents": [
                {
                    "text": "Efficient parsing with Linear Context-Free Rewriting Systems",
                    "sid": 0,
                    "ssid": null,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Previous work on treebank parsing with discontinuous constituents using Linear Rewriting systems has been limited to sentences of up to 30 words, for reasons of computational complexity.",
                    "sid": 1,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "There have been some results on an a manner that minimizes parsing complexity, but the present work shows that parsing long sentences with such an optimally binarized grammar remains infeasible.",
                    "sid": 2,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Instead, we introduce a technique which removes this length restriction, while maintaining a respectable accuracy.",
                    "sid": 3,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The resulting parser has been applied to a discontinuous treebank with favorable results.",
                    "sid": 4,
                    "ssid": 4,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "1 introduction",
            "number": "1",
            "sents": [
                {
                    "text": "Discontinuity in constituent structures (cf. figure 1 & 2) is important for a variety of reasons.",
                    "sid": 5,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For one, it allows a tight correspondence between syntax and semantics by letting constituent structure express argument structure (Skut et al., 1997).",
                    "sid": 6,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Other reasons are phenomena such as extraposition and word-order freedom, which arguably require discontinuous annotations to be treated systematically in phrase-structures (McCawley, 1982; Levy, 2005).",
                    "sid": 7,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Empirical investigations demonstrate that discontinuity is present in non-negligible amounts: around 30% of sentences contain discontinuity in two German treebanks (Maier and S\u00f8gaard, 2008; Maier and Lichte, 2009).",
                    "sid": 8,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Recent work on treebank parsing with discontinuous constituents (Kallmeyer and Maier, 2010; Maier, 2010; Evang and Kallmeyer, 2011; van Cranenburgh et al., 2011) shows that it is feasible to directly parse discontinuous constituency annotations, as given in the German Negra (Skut et al., 1997) and Tiger (Brants et al., 2002) corpora, or those that can be extracted from traces such as in the Penn treebank (Marcus et al., 1993) annotation.",
                    "sid": 9,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the computational complexity is such that until now, the length of sentences needed to be restricted.",
                    "sid": 10,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the case of Kallmeyer and Maier (2010) and Evang and Kallmeyer (2011) the limit was 25 words.",
                    "sid": 11,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Maier (2010) and van Cranenburgh et al. (2011) manage to parse up to 30 words with heuristics and optimizations, but no further.",
                    "sid": 12,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Algorithms have been suggested to binarize the grammars in such a way as to minimize parsing complexity, but the current paper shows that these techniques are not sufficient to parse longer sentences.",
                    "sid": 13,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Instead, this work presents a novel form of coarse-to-fine parsing which does alleviate this limitation.",
                    "sid": 14,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The rest of this paper is structured as follows.",
                    "sid": 15,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "First, we introduce linear context-free rewriting systems (LCFRS).",
                    "sid": 16,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Next, we discuss and evaluate binarization strategies for LCFRS.",
                    "sid": 17,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Third, we present a technique for approximating an LCFRS by a PCFG in a coarse-to-fine framework.",
                    "sid": 18,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Lastly, we evaluate this technique on a large corpus without the usual length restrictions.",
                    "sid": 19,
                    "ssid": 15,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "2 linear context-free rewriting systems",
            "number": "2",
            "sents": [
                {
                    "text": "Linear Context-Free Rewriting Systems (LCFRS; Vijay-Shanker et al., 1987; Weir, 1988) subsume a wide variety of mildly context-sensitive formalisms, such as Tree-Adjoining Grammar (TAG), Combinatory Categorial Grammar (CCG), Minimalist Grammar, Multiple Context-Free Grammar (MCFG) and synchronous CFG (Vijay-Shanker and Weir, 1994; Kallmeyer, 2010).",
                    "sid": 20,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Furthermore, they can be used to parse dependency structures (Kuhlmann and Satta, 2009).",
                    "sid": 21,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since LCFRS subsumes various synchronous grammars, they are also important for machine translation.",
                    "sid": 22,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This makes it possible to use LCFRS as a syntactic backbone with which various formalisms can be parsed by compiling grammars into an LCFRS, similar to the TuLiPa system (Kallmeyer et al., 2008).",
                    "sid": 23,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As all mildly context-sensitive formalisms, LCFRS are parsable in polynomial time, where the degree depends on the productions of the grammar.",
                    "sid": 24,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Intuitively, LCFRS can be seen as a generalization of context-free grammars to rewriting other objects than just continuous strings: productions are context-free, but instead of strings they can rewrite tuples, trees or graphs.",
                    "sid": 25,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We focus on the use of LCFRS for parsing with discontinuous constituents.",
                    "sid": 26,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This follows up on recent work on parsing the discontinuous annotations in German corpora with LCFRS (Maier, 2010; van Cranenburgh et al., 2011) and work on parsing the Wall Street journal corpus in which traces have been converted to discontinuous constituents (Evang and Kallmeyer, 2011).",
                    "sid": 27,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the case of parsing with discontinuous constituents a nonterminal may cover a tuple of discontinuous strings instead of a single, contiguous sequence of terminals.",
                    "sid": 28,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The number of components in such a tuple is called the fan-out of a rule, which is equal to the number of gaps plus one; the fan-out of the grammar is the maximum fan-out of its production.",
                    "sid": 29,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A context-free grammar is a LCFRS with a fan-out of 1.",
                    "sid": 30,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For convenience we will will use the rule notation of simple RCG (Boullier, 1998), which is a syntactic variant of LCFRS, with an arguably more transparent notation.",
                    "sid": 31,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A LCFRS is a tuple G = (N, T, V, P, 5).",
                    "sid": 32,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "N is a finite set of non-terminals; a function dim : N \u2014* N specifies the unique fan-out for every nonterminal symbol.",
                    "sid": 33,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "T and V are disjoint finite sets of terminals and variables.",
                    "sid": 34,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "5 is the distinguished start symbol with dim(5) = 1.",
                    "sid": 35,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "P is a finite set of rewrite rules (productions) of the form: and \u03b1i E (T U V)* for 1 < i < dim(Ai).",
                    "sid": 36,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Productions must be linear: if a variable occurs in a rule, it occurs exactly once on the left hand side (LHS), and exactly once on the right hand side (RHS).",
                    "sid": 37,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A rule is ordered if for any two variables X1 and X2 occurring in a non-terminal on the RHS, X1 precedes X2 on the LHS iff X1 precedes X2 on the RHS.",
                    "sid": 38,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Every production has a fan-out determined by the fan-out of the non-terminal symbol on the lefthand side.",
                    "sid": 39,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Apart from the fan-out productions also have a rank: the number of non-terminals on the right-hand side.",
                    "sid": 40,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These two variables determine the time complexity of parsing with a grammar.",
                    "sid": 41,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A production can be instantiated when its variables can be bound to non-overlapping spans such that for each component \u03b1i of the LHS, the concatenation of its terminals and bound variables forms a contiguous span in the input, while the endpoints of each span are non-contiguous.",
                    "sid": 42,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As in the case of a PCFG, we can read off LCFRS productions from a treebank (Maier and S\u00f8gaard, 2008), and the relative frequencies of productions form a maximum likelihood estimate, for a probabilistic LCFRS (PLCFRS), i.e., a (discontinuous) treebank grammar.",
                    "sid": 43,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As an example, figure 3 shows the productions extracted from the tree in figure 2.",
                    "sid": 44,
                    "ssid": 25,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "3 binarization",
            "number": "3",
            "sents": [
                {
                    "text": "A probabilistic LCFRS can be parsed using a CKYlike tabular parsing algorithm (cf.",
                    "sid": 45,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Kallmeyer and Maier, 2010; van Cranenburgh et al., 2011), but this requires a binarized grammar.1 Any LCFRS can be binarized.",
                    "sid": 46,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Crescenzi et al. (2011) state \u201cwhile CFGs can always be reduced to rank two (Chomsky Normal Form), this is not the case for LCFRS with any fan-out greater than one.\u201d However, this assertion is made under the assumption of a fixed fan-out.",
                    "sid": 47,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "If this assumption is relaxed then it is easy to binarize either deterministically or, as will be investigated in this work, optimally with a dynamic programming approach.",
                    "sid": 48,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Binarizing an LCFRS may increase its fan-out, which results in an increase in asymptotic complexity.",
                    "sid": 49,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Consider the following production: Henceforth, we assume that non-terminals on the right-hand side are ordered by the order of their first variable on the left-hand side.",
                    "sid": 50,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "There are two ways to binarize this production.",
                    "sid": 51,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The first is from left to right: This binarization introduces a production with a fan-out of 2, which could have been avoided.",
                    "sid": 52,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "After binarization, an LCFRS can be parsed in O(|G |\u00b7 |w|p) time, where |G |is the size of the grammar, |w |is the length of the sentence.",
                    "sid": 53,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The degree p of the polynomial is the maximum parsing complexity of a rule, defined as: parsing complexity := \u03d5 + \u03d51 + \u03d52 (6) where \u03d5 is the fan-out of the left-hand side and \u03d51 and \u03d52 are the fan-outs of the right-hand side of the rule in question (Gildea, 2010).",
                    "sid": 54,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As Gildea (2010) shows, there is no one to one correspondence between fan-out and parsing complexity: it is possible that parsing complexity can be reduced by increasing the fan-out of a production.",
                    "sid": 55,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In other words, there can be a production which can be binarized with a parsing complexity that is minimal while its fan-out is sub-optimal.",
                    "sid": 56,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore we focus on parsing complexity rather than fan-out in this work, since parsing complexity determines the actual time complexity of parsing with a grammar.",
                    "sid": 57,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "There has been some work investigating whether the increase in complexity can be minimized effectively (G\u00b4omez-Rodr\u00b4\u0131guez et al., 2009; Gildea, 2010; Crescenzi et al., 2011).",
                    "sid": 58,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "More radically, it has been suggested that the power of LCFRS should be limited to well-nested structures, which gives an asymptotic improvement in parsing time (G\u00b4omez-Rodr\u00b4\u0131guez et al., 2010).",
                    "sid": 59,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, there is linguistic evidence that not all language use can be described in wellnested structures (Chen-Main and Joshi, 2010).",
                    "sid": 60,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore we will use the full power of LCFRS in this work\u2014parsing complexity is determined by the treebank, not by a priori constraints.",
                    "sid": 61,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Apart from optimizing for parsing complexity, for linguistic reasons it can also be useful to parse the head of a constituent first, yielding so-called head-driven binarizations (Collins, 1999).",
                    "sid": 62,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Additionally, such a head-driven binarization can be \u2018Markovized\u2019\u2013i.e., the resulting production can be constrained to apply to a limited amount of horizontal context as opposed to the full context in the original constituent (e.g., Klein and Manning, 2003), which can have a beneficial effect on accuracy.",
                    "sid": 63,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the notation of Klein and Manning (2003) there are two Markovization parameters: h and v. The first parameter describes the amount of horizontal context for the artificial labels of a binarized production.",
                    "sid": 64,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In a normal form binarization, this parameter equals infinity, because the binarized production should only apply in the exact same context as the context in which it originally belongs, as otherwise the set of strings accepted by the grammar would be affected.",
                    "sid": 65,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An artificial label will have the form XA\ufffdB\ufffdC for a binarized production of a constituent X that has covered children A, B, and C of X.",
                    "sid": 66,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The other extreme, h = 1, enables generalizations by stringing parts of binarized constituents together, as long as they share one non-terminal.",
                    "sid": 67,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the previous example, the label would become just XA, i.e., the presence of B and C would no longer be required, which enables switching to any binarized production that has covered A as the last node.",
                    "sid": 68,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Limiting the amount of horizontal context on which a production is conditioned is important when the treebank contains many unique constituents which can only be parsed by stringing together different binarized productions; in other words, it is a way of dealing with the data sparseness about n-ary productions in the treebank.",
                    "sid": 69,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second parameter describes parent annotation, which will not be investigated in this work; the default value is v = 1 which implies only including the immediate parent of the constituent that is being binarized; including grandparents is a way of weakening independence assumptions.",
                    "sid": 70,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Crescenzi et al. (2011) also remark that an optimal head-driven binarization allows for Markovization.",
                    "sid": 71,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, it is questionable whether such a binarization is worthy of the name Markovization, as the non-terminals are not introduced deterministically from left to right, but in an arbitrary fashion dictated by concerns of parsing complexity; as such there is not a Markov process based on a meaningful (e.g., temporal) ordering and there is no probabilistic interpretation of Markovization in such a setting.",
                    "sid": 72,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To summarize, we have at least four binarization strategies (cf. figure 4 for an illustration): tion with horizontal Markovization.",
                    "sid": 73,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Minimizes parsing complexity.",
                    "sid": 74,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Introduced in and proven to be NP-hard by Crescenzi et al. (2011).",
                    "sid": 75,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An issue with the minimal binarizations is that the algorithm for finding them has a high computational complexity, and has not been evaluated empirically on treebank data.2 Empirical investigation is interesting for two reasons.",
                    "sid": 76,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "First of all, the high computational complexity may not be relevant with constant factors of constituents, which can reasonably be expected to be relatively small.",
                    "sid": 77,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Second, it is important to establish whether an asymptotic improvement is actually obtained through optimal binarizations, and whether this translates to an improvement in practice.",
                    "sid": 78,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Gildea (2010) presents a general algorithm to binarize an LCFRS while minimizing a given scoring function.",
                    "sid": 79,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will use this algorithm with two different scoring functions.",
                    "sid": 80,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The first directly optimizes parsing complexity.",
                    "sid": 81,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given a (partially) binarized constituent c, the function returns a tuple of scores, for which a linear order is defined by comparing elements starting from the most significant (left-most) element.",
                    "sid": 82,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The tuples contain the parsing complexity p, and the fan-out \u03d5 to break ties in parsing complexity; if there are still ties after considering the fan-out, the sum of the parsing complexities of the subtrees of c is considered, which will give preference to a binarization where the worst case complexity occurs once instead of twice.",
                    "sid": 83,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The formula is then: The second function is the similar except that only head-driven strategies are accepted.",
                    "sid": 84,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A headdriven strategy is a binarization in which the head is introduced first, after which the rest of the children are introduced one at a time.",
                    "sid": 85,
                    "ssid": 41,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given a (partial) binarization c, the score should reflect the maximum complexity and fan-out in that binarization, to optimize for the worst case, as well as the sum, to optimize the average case.",
                    "sid": 86,
                    "ssid": 42,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This aspect appears to be glossed over by Gildea (2010).",
                    "sid": 87,
                    "ssid": 43,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Considering only the score of the last production in a binarization produces suboptimal binarizations.",
                    "sid": 88,
                    "ssid": 44,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As data we use version 2 of the Negra (Skut et al., 1997) treebank, with the common training, development and test splits (Dubey and Keller, 2003).",
                    "sid": 89,
                    "ssid": 45,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Following common practice, punctuation, which is left out of the phrase-structure in Negra, is reattached to the nearest constituent.",
                    "sid": 90,
                    "ssid": 46,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the course of experiments it was discovered that the heuristic method for punctuation attachment used in previous work (e.g., Maier, 2010; van Cranenburgh et al., 2011), as implemented in rparse,3 introduces additional discontinuity.",
                    "sid": 91,
                    "ssid": 47,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We applied a slightly different heuristic: punctuation is attached to the highest constituent that contains a neighbor to its right.",
                    "sid": 92,
                    "ssid": 48,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The result is that punctuation can be introduced into the phrase-structure without any additional discontinuity, and thus without artificially inflating the fan-out and complexity of grammars read off from the treebank.",
                    "sid": 93,
                    "ssid": 49,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This new heuristic provides a significant improvement: instead of a fan-out of 9 and a parsing complexity of 19, we obtain values of 4 and 9 respectively.",
                    "sid": 94,
                    "ssid": 50,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The parser is presented with the gold part-ofspeech tags from the corpus.",
                    "sid": 95,
                    "ssid": 51,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For reasons of efficiency we restrict sentences to 25 words (including punctuation) in this experiment: NEGRA-25.",
                    "sid": 96,
                    "ssid": 52,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A grammar was read off from the training part of NEGRA-25, and sentences of up to 25 words in the development set were parsed using the resulting PLCFRS, using the different binarization schemes.",
                    "sid": 97,
                    "ssid": 53,
                    "kind_of_tag": "s"
                },
                {
                    "text": "First with aright-branching, right-to-left binarization, and second with the minimal binarization according to parsing complexity andfanout.",
                    "sid": 98,
                    "ssid": 54,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The last two binarizations are head-driven and Markovized\u2014the first straightforwardly from left-to-right, the latter optimized for minimal parsing complexity.",
                    "sid": 99,
                    "ssid": 55,
                    "kind_of_tag": "s"
                },
                {
                    "text": "With Markovization we are forced to add a level of parent annotation to tame the increase in productivity caused by h = 1.",
                    "sid": 100,
                    "ssid": 56,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The distribution of parsing complexity (measured with eq.",
                    "sid": 101,
                    "ssid": 57,
                    "kind_of_tag": "s"
                },
                {
                    "text": "6) in the grammars with different binarization strategies is shown in figure 5 and 6.",
                    "sid": 102,
                    "ssid": 58,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Although the optimal binarizations do seem to have some effect on the distribution of parsing complexities, it remains to be seen whether this can be cashed out as a performance improvement in practice.",
                    "sid": 103,
                    "ssid": 59,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To this end, we also parse using the binarized grammars.",
                    "sid": 104,
                    "ssid": 60,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this work we binarize and parse with disco-dop introduced in van Cranenburgh et al. (2011).4 In this experiment we report scores of the (exact) Viterbi derivations of a treebank PLCFRS; cf. table 1 for the results.",
                    "sid": 105,
                    "ssid": 61,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Times represent CPU time (single core); accuracy is given with a generalization of PARSEVAL to discontinuous structures, described in Maier (2010).",
                    "sid": 106,
                    "ssid": 62,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Instead of using Maier\u2019s implementation of discontinuous Fi scores in rparse, we employ a variant that ignores (a) punctuation, and (b) the root node of each tree.",
                    "sid": 107,
                    "ssid": 63,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This makes our evaluation incomparable to previous results on discontinuous parsing, but brings it in line with common practice on the Wall street journal benchmark.",
                    "sid": 108,
                    "ssid": 64,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that this change yields scores about 2 or 3 percentage points lower than those of rparse.",
                    "sid": 109,
                    "ssid": 65,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Despite the fact that obtaining optimal binarizations is exponential (Gildea, 2010) and NPhard (Crescenzi et al., 2011), they can be computed relatively quickly on this data set.5 Importantly, in the first case there is no improvement on fan-out or parsing complexity, while in the head-driven case there is a minimal improvement because of a single production with parsing complexity 15 without optimal binarization.",
                    "sid": 110,
                    "ssid": 66,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the other hand, the optimal binarizations might still have a significant effect on the average case complexity, rather than the worst-case complexities.",
                    "sid": 111,
                    "ssid": 67,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Indeed, in both cases parsing with the optimal grammar is faster; in the first case, however, when the time for binarization is considered as well, this advantage mostly disappears.",
                    "sid": 112,
                    "ssid": 68,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The difference in Fi scores might relate to the efficacy of Markovization in the binarizations.",
                    "sid": 113,
                    "ssid": 69,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It should be noted that it makes little theoretical sense to \u2018Markovize\u2019 a binarization when it is not a left-to-right or right-to-left binarization, because with an optimal binarization the non-terminals of a constituent are introduced in an arbitrary order.",
                    "sid": 114,
                    "ssid": 70,
                    "kind_of_tag": "s"
                },
                {
                    "text": "More importantly, in our experiments, these techniques of optimal binarizations did not scale to longer sentences.",
                    "sid": 115,
                    "ssid": 71,
                    "kind_of_tag": "s"
                },
                {
                    "text": "While it is possible to obtain an optimal binarization of the unrestricted Negra corpus, parsing long sentences with the resulting grammar remains infeasible.",
                    "sid": 116,
                    "ssid": 72,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore we need to look at other techniques for parsing longer sentences.",
                    "sid": 117,
                    "ssid": 73,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will stick with the straightforward head-driven, head-outward binarization strategy, despite this being a computationally sub-optimal binarization.",
                    "sid": 118,
                    "ssid": 74,
                    "kind_of_tag": "s"
                },
                {
                    "text": "One technique for efficient parsing of LCFRS is the use of context-summary estimates (Kallmeyer and Maier, 2010), as part of a best-first parsing algorithm.",
                    "sid": 119,
                    "ssid": 75,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This allowed Maier (2010) to parse sentences of up to 30 words.",
                    "sid": 120,
                    "ssid": 76,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the calculation of these estimates is not feasible for longer sentences and large grammars (van Cranenburgh et al., 2011).",
                    "sid": 121,
                    "ssid": 77,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Another strategy is to perform an online approximation of the sentence to be parsed, after which parsing with the LCFRS can be pruned effectively.",
                    "sid": 122,
                    "ssid": 78,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is the strategy that will be explored in the current work.",
                    "sid": 123,
                    "ssid": 79,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "4 context-free grammar approximation for coarse-to-fine parsing",
            "number": "4",
            "sents": [
                {
                    "text": "Coarse-to-fine parsing (Charniak et al., 2006) is a technique to speed up parsing by exploiting the information that can be gained from parsing with simpler, coarser grammars\u2014e.g., a grammar with a smaller set of labels on which the original grammar can be projected.",
                    "sid": 124,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Constituents that do not contribute to a full parse tree with a coarse grammar can be ruled out for finer grammars as well, which greatly reduces the number of edges that need to be explored.",
                    "sid": 125,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, by changing just the labels only the grammar constant is affected.",
                    "sid": 126,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "With discontinuous treebank parsing the asymptotic complexity of the grammar also plays a major role.",
                    "sid": 127,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore we suggest to parse not just with a coarser grammar, but with a coarser grammar formalism, following a suggestion in van Cranenburgh et al. (2011).",
                    "sid": 128,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This idea is inspired by the work of Barth\u00b4elemy et al. (2001), who apply it in a non-probabilistic setting where the coarse grammar acts as a guide to the non-deterministic choices of the fine grammar.",
                    "sid": 129,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Within the coarse-to-fine approach the technique becomes a matter of pruning with some probabilistic threshold.",
                    "sid": 130,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Instead of using the coarse grammar only as a guide to solve non-deterministic choices, we apply it as a pruning step which also discards the most suboptimal parses.",
                    "sid": 131,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The basic idea is to extract a grammar that defines a superset of the language we want to parse, but with a fanout of 1.",
                    "sid": 132,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "More concretely, a context-free grammar can be read off from discontinuous trees that have been transformed to context-free trees by the procedure introduced in Boyd (2007).",
                    "sid": 133,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each discontinuous node is split into a set of new nodes, one for each component; for example a node NP2 will be split into two nodes labeled NP*1 and NP*2 (like Barth\u00b4elemy et al., we mark components with an index to reduce overgeneration).",
                    "sid": 134,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Because Boyd\u2019s transformation is reversible, chart items from this grammar can be converted back to discontinuous chart items, and can guide parsing of an LCFRS.",
                    "sid": 135,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This guiding takes the form of a white list.",
                    "sid": 136,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "After parsing with the coarse grammar, the resulting chart is pruned by removing all items that fail to meet a certain criterion.",
                    "sid": 137,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In our case this is whether a chart item is part of one of the k-best derivations\u2014we use k = 50 in all experiments (as in van Cranenburgh et al., 2011).",
                    "sid": 138,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This has similar effects as removing items below a threshold of marginalized posterior probability; however, the latter strategy requires computation of outside probabilities from a parse forest, which is more involved with an LCFRS than with a PCFG.",
                    "sid": 139,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "When parsing with the fine grammar, whenever a new item is derived, the white list is consulted to see whether this item is allowed to be used in further derivations; otherwise it is immediately discarded.",
                    "sid": 140,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This coarse-to-fine approach will be referred to as CFG-CTF, and the transformed, coarse grammar will be referred to as a split-PCFG.",
                    "sid": 141,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Splitting discontinuous nodes for the coarse grammar introduces new nodes, so obviously we need to binarize after this transformation.",
                    "sid": 142,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the other hand, the coarse-to-fine approach requires a mapping between the grammars, so after reversing the transformation of splitting nodes, the resulting discontinuous trees must be binarized (and optionally Markovized) in the same manner as those on which the fine grammar is based.",
                    "sid": 143,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To resolve this tension we elect to binarize twice.",
                    "sid": 144,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The first time is before splitting discontinuous nodes, and this is where we introduce Markovization.",
                    "sid": 145,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This same binarization will be used for the fine grammar as well, which ensures the models make the same kind of generalizations.",
                    "sid": 146,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second binarization is after splitting nodes, this time with a binary normal form (2NF; all productions are either unary, binary, or lexical).",
                    "sid": 147,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Parsing with this grammar proceeds as follows.",
                    "sid": 148,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "After obtaining an exhaustive chart from the coarse stage, the chart is pruned so as to only contain items occurring in the k-best derivations.",
                    "sid": 149,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "When parsing in the fine stage, each new item is looked up in this pruned coarse chart, with multiple lookups if the item is discontinuous (one for each component).",
                    "sid": 150,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To summarize, the transformation happens in four steps (cf. figure 7 for an illustration):",
                    "sid": 151,
                    "ssid": 28,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "5 evaluation",
            "number": "5",
            "sents": [
                {
                    "text": "We evaluate on Negra with the same setup as in section 3.3.",
                    "sid": 152,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We report discontinuous Fi scores as well as exact match scores.",
                    "sid": 153,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For previous results on discontinuous parsing with Negra, see table 3.",
                    "sid": 154,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For results with the CFG-CTF method see table 4.",
                    "sid": 155,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We first establish the viability of the CFG-CTF method on NEGRA-25, with a head-driven v = 1, h = 2 binarization, and reporting again the scores of the exact Viterbi derivations from a treebank PLCFRS versus a PCFG using our transformations.",
                    "sid": 156,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 8 compares the parsing times of LCFRS with and without the new CFG-CTF method.",
                    "sid": 157,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The graph shows a steep incline for parsing with LCFRS directly, which makes it infeasible to parse longer sentences, while the CFG-CTF method is faster for sentences of length > 22 despite its overhead of parsing twice.",
                    "sid": 158,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second experiment demonstrates the CFGCTF technique on longer sentences.",
                    "sid": 159,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We restrict the length of sentences in the training, development and test corpora to 40 words: NEGRA-40.",
                    "sid": 160,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As a first step we apply the CFG-CTF technique to parse with a PLCFRS as the fine grammar, pruning away all items not occurring in the 10,000 best derivations from the PCFG chart.",
                    "sid": 161,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The result shows that the PLCFRS gives a slight improvement over the split-pcfg, which accords with the observation that the latter makes stronger independence assumptions in the case of discontinuity.",
                    "sid": 162,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the next experiments we turn to an allfragments grammar encoded in a PLCFRS using Goodman\u2019s (2003) reduction, to realize a (discontinuous) Data-Oriented Parsing (DOP; Scha, 1990) model\u2014which goes by the name of DiscoDOP (van Cranenburgh et al., 2011).",
                    "sid": 163,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This provides an effective yet conceptually simple method to weaken the independence assumptions of treebank grammars.",
                    "sid": 164,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 2 gives statistics on the grammars, including the parsing complexities.",
                    "sid": 165,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The fine grammar has a parsing complexity of 9, which means that parsing with this grammar has complexity O(|w|9).",
                    "sid": 166,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We use the same parameters as van Cranenburgh et al. (2011), except that unlike van Cranenburgh et al., we can use v = 1, h = 1 Markovization, in order to obtain a higher coverage.",
                    "sid": 167,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The DOP grammar is added as a third stage in the coarse-to-fine pipeline.",
                    "sid": 168,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This gave slightly better results than substituting the the DOP grammar for the PLCFRS stage.",
                    "sid": 169,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Parsing with NEGRA-40 took about 11 hours and 4 GB of memory.",
                    "sid": 170,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The same model from NEGRA-40 can also be used to parse the full development set, without length restrictions, establishing that the CFG-CTF method effectively eliminates any limitation of length for parsing with LCFRS.",
                    "sid": 171,
                    "ssid": 20,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "6 conclusion",
            "number": "6",
            "sents": [
                {
                    "text": "Our results show that optimal binarizations are clearly not the answer to parsing LCFRS efficiently, as they do not significantly reduce parsing complexity in our experiments.",
                    "sid": 172,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "While they provide some efficiency gains, they do not help with the main problem of longer sentences.",
                    "sid": 173,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We have presented a new technique for largescale parsing with LCFRS, which makes it possible to parse sentences of any length, with favorable accuracies.",
                    "sid": 174,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The availability of this technique may lead to a wider acceptance of LCFRS as a syntactic backbone in computational linguistics.",
                    "sid": 175,
                    "ssid": 4,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "acknowledgments",
            "number": "7",
            "sents": [
                {
                    "text": "I am grateful to Willem Zuidema, Remko Scha, Rens Bod, and three anonymous reviewers for comments.",
                    "sid": 176,
                    "ssid": 1,
                    "kind_of_tag": "s"
                }
            ]
        }
    ]
}