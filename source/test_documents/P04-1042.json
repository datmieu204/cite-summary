{
    "ID": "P04-1042",
    "sections": [
        {
            "text": "abstract",
            "number": 0,
            "sents": [
                {
                    "text": "Deep Dependencies From Context-Free Statistical Parsers: Correcting The Surface Dependency Approximation",
                    "sid": 0,
                    "ssid": null,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We present a linguistically-motivated algorithm for reconstructing nonlocal dependency in broad-coverage context-free parse trees derived from treebanks.",
                    "sid": 1,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We use an algorithm based on loglinear classifiers to augment and reshape context-free trees so as to reintroduce underlying nonlocal dependencies lost in the context-free approximation.",
                    "sid": 2,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We find that our algorithm compares favorably with prior work on English using an existing evaluation metric, and also introduce and argue for a new dependency-based evaluation metric.",
                    "sid": 3,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By this new evaluation metric our algorithm achieves 60% error reduction on gold-standard input trees and 5% error reduction on state-ofthe-art machine-parsed input trees, when compared with the best previous work.",
                    "sid": 4,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We also present the first results on nonlocal dependency reconstruction for a language other than English, comparing performance on English and German.",
                    "sid": 5,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our new evaluation metric quantitatively corroborates the intuition that in a language with freer word order, the surface dependencies in context-free parse trees are a poorer approximation to underlying dependency structure.",
                    "sid": 6,
                    "ssid": 6,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "1 introduction",
            "number": "1",
            "sents": [
                {
                    "text": "While parsers are been used for other purposes, the primary motivation for syntactic parsing is as an aid to semantic interpretation, in pursuit of broader goals of natural language understanding.",
                    "sid": 7,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Proponents of traditional \u2018deep\u2019 or \u2018precise\u2019 approaches to syntax, such as GB, CCG, HPSG, LFG, or TAG, have argued that sophisticated grammatical formalisms are essential to resolving various hidden relationships such as the source phrase of moved whphrases in questions and relativizations, or the controller of clauses without an overt subject.",
                    "sid": 8,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Knowledge of these hidden relationships is in turn essential to semantic interpretation of the kind practiced in the semantic parsing (Gildea and Jurafsky, 2002) and QA (Pasca and Harabagiu, 2001) literatures.",
                    "sid": 9,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, work in statistical parsing has for the most part put these needs aside, being content to recover surface context-free (CF) phrase structure trees.",
                    "sid": 10,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This perhaps reflects the fact that context-free phrase structure grammar (CFG) is in some sense at the the heart of the majority of both formal and computational syntactic research.",
                    "sid": 11,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Although, upon introducing it, Chomsky (1956) rejected CFG as an adequate framework for natural language description, the majority of work in the last half century has used context-free structural descriptions and related methodologies in one form or another as an important component of syntactic analysis.",
                    "sid": 12,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "CFGs seem adequate to weakly generate almost all common natural language structures, and also facilitate a transparent predicate-argument and/or semantic interpretation for the more basic ones (Gazdar et al., 1985).",
                    "sid": 13,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Nevertheless, despite their success in providing surface phrase structure analyses, if statistical parsers and the representations they produce do not provide a useful stepping stone to recovering the hidden relationships, they will ultimately come to be seen as a dead end, and work will necessarily return to using richer formalisms.",
                    "sid": 14,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper we attempt to establish to what degree current statistical parsers are a useful step in analysis by examining the performance of further statistical classifiers on non-local dependency recovery from CF parse trees.",
                    "sid": 15,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The natural isomorphism from CF trees to dependency trees induces only local dependencies, derived from the headsister relation in a CF local tree.",
                    "sid": 16,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, if the output of a context-free parser can be algorithmically augmented to accurately identify and incorporate nonlocal dependencies, then we can say that the context-free parsing model is a safe approximation to the true task of dependency reconstruction.",
                    "sid": 17,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We investigate the safeness of this approximation, devising an algorithm to reconstruct non-local dependencies from context-free parse trees using loglinear classifiers, tested on treebanks of not only English but also German, a language with much freer word order and correspondingly more discontinuity than English.",
                    "sid": 18,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This algorithm can be used as an intermediate step between the surface output trees of modern statistical parsers and semantic interpretation systems for a variety of tasks.1 Previous work on nonlocal dependency has focused entirely on English, despite the disparity in type and frequency of various non-local dependency constructions for varying languages (Kruijff, 2002).",
                    "sid": 19,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Collins (1999)\u2019s Model 3 investigated GPSG-style trace threading for resolving nonlocal relative pronoun dependencies.",
                    "sid": 20,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Johnson (2002) was the first post-processing approach to non-local dependency recovery, using a simple pattern-matching algorithm on context-free trees.",
                    "sid": 21,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Dienes and Dubey (2003a,b) and Dienes (2003) approached the problem by preidentifying empty categories using an HMM on unparsed strings and threaded the identified empties into the category structure of a context-free parser, finding that this method compared favorably with both Collins\u2019 and Johnson\u2019s.",
                    "sid": 22,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Traditional LFG parsing, in both non-stochastic (Kaplan and Maxwell, 1993) and stochastic (Riezler et al., 2002; Kaplan et al., 2004) incarnations, also divides the labor of local and nonlocal dependency identification into two phases, starting with context-free parses and continuing by augmentation with functional information.",
                    "sid": 23,
                    "ssid": 17,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "2 datasets",
            "number": "2",
            "sents": [
                {
                    "text": "The datasets used for this study consist of the Wall Street Journal section of the Penn Treebank of English (WSJ) and the context-free version of the NEGRA (version 2) corpus of German (Skut et al., 1997b).",
                    "sid": 24,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Full-size experiments on WSJ described in Section 4 used the standard sections 2-21 for training, 24 for development, and trees whose yield is under 100 words from section 23 for testing.",
                    "sid": 25,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Experiments described in Section 4.3 used the same development and test sets but files 200-959 of WSJ as a smaller training set; for NEGRA we followed Dubey and Keller (2003) in using the first 18,602 sentences for training, the last 1,000 for development, and the previous 1,000 for testing.",
                    "sid": 26,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Consistent with prior work and with common practice in statistical parsing, we stripped categories of all functional tags prior to training and testing (though in several cases this seems to have been a limiting move; see Section 5).",
                    "sid": 27,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Nonlocal dependency annotation in Penn Treebanks can be divided into three major types: unindexed empty elements, dislocations, and control.",
                    "sid": 28,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The first type consists primarily of null complementizers, as exemplified in Figure 1 by the null relative pronoun 0 (c.f. aspects that it sees), and do not participate in (though they may mediate) nonlocal dependency.",
                    "sid": 29,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second type consists of a dislocated element coindexed with an origin site of semantic interpretation, as in the association in Figure 1 of WHNP-1 with the direct object position of sees (a relativization), and the association of S2 with the ADJP quick (a right dislocation).",
                    "sid": 30,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This type encompasses the classic cases of nonlocal dependency: topicalization, relativization, wh- movement, and right dislocation, as well as expletives and other instances of non-canonical argument positioning.",
                    "sid": 31,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The third type involves control loci in syntactic argument positions, sometimes coindexed with overt controllers, as in the association of the NP Farmers with the empty subject position of the S2 node.",
                    "sid": 32,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "(An example of a control locus with no controller would be [S NP-* [VP Eating ice cream ]] is fun.)",
                    "sid": 33,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Controllers are to be interpreted as syntactic (and possibly semantic) arguments both in their overt position and in the position of loci they control.",
                    "sid": 34,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This type encompasses raising, control, passivization, and unexpressed subjects of to- infinitive and gerund verbs, among other constructions.2 NEGRA\u2019s original annotation is as dependency trees with phrasal nodes, crossing branches, and no empty elements.",
                    "sid": 35,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the distribution includes a context-free version produced algorithmically by recursively remapping discontinuous parts of nodes upward into higher phrases and marking their sites of origin.3 The resulting \u201ctraces\u201d correspond roughly to a subclass of the second class of Penn Treebank empties discussed above, and include wh- movement, topicalization, right extrapositions from NP, expletives, and scrambling of subjects after other complements.",
                    "sid": 36,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The positioning of NEGRA\u2019s \u201ctraces\u201d inside the mother node is completely algorithmic; a dislocated constituent C has its trace at the edge of the original mother closest to C\u2019s overt position.",
                    "sid": 37,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Given a context-free NEGRA tree shorn of its trace/antecedent notation, however, it is far from trivial to determine which nodes are dislocated, and where they come from.",
                    "sid": 38,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 2 shows an annotated sentence from the NEGRA corpus with discontinuities due to right extraposition (*T1*) and topicalization (*T2*), before and after transformation into context-free form with traces.",
                    "sid": 39,
                    "ssid": 16,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "3 algorithm",
            "number": "3",
            "sents": [
                {
                    "text": "Corresponding to the three types of empty-element annotation found in the Penn Treebank, our algorithm divides the process of CF tree enhancement into three phases.",
                    "sid": 40,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each phase involves the identification of a certain subset of tree nodes to be operated on, followed by the application of the appropriate operation to the node.",
                    "sid": 41,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Operations may involve the insertion of a category at some position among a node\u2019s daughters; the marking of certain nodes as dislocated; or the relocation of dislocated nodes to other positions within the tree.",
                    "sid": 42,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The content and ordering of phases is consistent with the syntactic theory upon which treebank annotation is based.",
                    "sid": 43,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, WSJ annotates relative clauses lacking overt relative pronouns, such as the SBAR in Figure 1, with a trace in the relativization site whose antecedent is an empty relative pronoun.",
                    "sid": 44,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This requires that empty relative pronoun insertion precede dislocated element identification.",
                    "sid": 45,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Likewise, dislocated elements can serve as controllers of control loci, based on their originating site, so it is sensible to return dislocated nodes to their originating sites before identifying control loci and their controllers.",
                    "sid": 46,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For WSJ, the three phases are: Note in particular that phase 2 involves the classification of overt tree nodes as dislocated, followed by the identification of an origin site (annotated in the treebank as an empty node) for each dislocated element; whereas phase 3 involves the identification of (empty) control loci first, and of controllers later.",
                    "sid": 47,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This approach contrasts with Johnson (2002), who treats empty/antecedent identification as a joint task, and with Dienes and Dubey (2003a,b), who always identify empties first and determine antecedents later.",
                    "sid": 48,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our motivation is that it should generally be easier to determine whether an overt element is dislocated than whether a given position is the origin of some yet unknown dislocated element (particularly in the absence of a sophisticated model of argument expression); but control loci are highly predictable from local context, such as the subjectless non-finite S in Figure 1\u2019s S-2.5 Indeed this difference seems to be implicit in the nonlocal feature templates used by Dienes and Dubey (2003a,b) in their empty element tagger, in particular lookback for wh- words preceding a candidate verb.",
                    "sid": 49,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As described in Section 2, NEGRA\u2019s nonlocal annotation schema is much simpler, involving no 4The WSJ contains a number of SBARs headed by empty complementizers with trace S\u2019s.",
                    "sid": 50,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These SBARs are introduced in our algorithm as projections of identified empty complementizers as daughters of non-SBAR categories.",
                    "sid": 51,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "5Additionally, whereas dislocated nodes are always overt, control loci may be controlled by other (null) control loci, meaning that identifying controllers before control loci would still entail looking for nulls. uncoindexed empties or control loci.",
                    "sid": 52,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Correspondingly, our NEGRA algorithm includes only phase 2 of the WSJ algorithm, step (c) of which is trivial for NEGRA due to the deterministic positioning of trace insertion in the treebank.",
                    "sid": 53,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In each case we use a loglinear model for node classification, with a combination of quadratic regularization and thresholding by individual feature count to prevent overfitting.",
                    "sid": 54,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the second and third parts of phases 2 and 3, when determining an originating site or controller for a given node N, or an insertion position for a node N' in N, we use a competition-based setting, using a binary classification (yes/no for association with N) on each node in the tree, and during testing choosing the node with the highest score for positive association with N.6 All other phases of classification involve independent decisions at each node.",
                    "sid": 55,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In phase 3, we include a special zero node to indicate a control locus with no antecedent.",
                    "sid": 56,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each subphase of our dependency reconstruction algorithm involves the training of a separate model and the development of a separate feature set.",
                    "sid": 57,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We found that it was important to include both a variety of general feature templates and a number of manually designed, specialized features to resolve specific problems observed for individual classifiers.",
                    "sid": 58,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We developed all feature templates exclusively on the training and development sets specified in Section 2. coded as follows.",
                    "sid": 59,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The prefixes {\u2205,M,G,D,R} indicate that the feature value is calculated with respect to the node in question, its mother, grandmother, daughter, or relative node respectively.7 {CAT,POS,TAG,WORD} stand for syntactic category, position (of daughter) in mother, head tag, and head word respectively.",
                    "sid": 60,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, when determining whether an infinitival VP is extraposed, such as S-2 in Figure 1, the plausibility of the VP head being a deep dependent of the head verb is captured with the MHD\u00d7HD template.",
                    "sid": 61,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "(FIRST/LAST)CAT and (L/RSIS)CAT are templates used for choosing the position to insert insert relocated nodes, respectively recording whether a node of a given category is the first/last daughter, and the syntactic category of a node\u2019s left/right sisters.",
                    "sid": 62,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "PATH is the syntactic path between relative and base node, defined as the list of the syntactic categories on the (inclusive) node path linking the relative node to the node in question, paired with whether the step on the path was upward or downward.",
                    "sid": 63,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, in Figure 2 the syntactic path from VP-1 to PP is [\u2191-VP,\u2191S,\u2193-VP,\u2193-PP].",
                    "sid": 64,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is a crucial feature for the relativized classifiers RELOCATEMOVED and FINDCONTROLLER; in an abstract sense it mediates the gap-threading information incorporated into GPSGstyle (Gazdar et al., 1985) parsers, and in concrete terms it closely matches the information derived from Johnson (2002)\u2019s connected local tree set patterns.",
                    "sid": 65,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Gildea and Jurafsky (2002) is to our knowledge the first use of such a feature for classification tasks on syntactic trees; they found it important for the related task of semantic role identification.",
                    "sid": 66,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We expressed specialized hand-coded feature templates as tree-matching patterns that capture a fragment of the content of the pattern in the feature value.",
                    "sid": 67,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Representative examples appear in Figure 3.",
                    "sid": 68,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The italicized node is the node for which a given feature is recorded; underscores indicate variables that can match any category; and the angle-bracketed parts of the tree fragment, together with an index for the pattern, determine the feature value.8",
                    "sid": 69,
                    "ssid": 30,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "4 evaluation",
            "number": "4",
            "sents": [
                {
                    "text": "Our algorithm\u2019s performance can be compared with the work of Johnson (2002) and Dienes and Dubey (2003a) on WSJ.",
                    "sid": 70,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Valid comparisons exist for the insertion of uncoindexed empty nodes (COMP and ARB-SUBJ), identification of control and raising loci (CONTROLLOCUS), and pairings of dislocated and controller/raised nodes with their origins (DISLOC,CONTROLLER).",
                    "sid": 71,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In Table 2 we present comparative results, using the PARSEVAL-based evaluation metric introduced by Johnson (2002) \u2013 a correct empty category inference requires the string position of the empty category, combined with the left and right boundaries plus syntactic category of the antecedent, if any, for purposes of comparison.9,10 Note that this evaluation metric does not require correct attachment of the empty category into the parse tree.",
                    "sid": 72,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In Figure 1, for example, WHNP1 could be erroneously remapped to the right edge of any S or VP node in the sentence without resulting in error according to this metric.",
                    "sid": 73,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We therefore abandon this metric in further evaluations as it is not clear whether it adequately approximates performance in predicate-argument structure recovery.11 If we think of a statistical parser as a function from strings to CF trees, and the nonlocal dependency recovery algorithm A presented in this paper as a function from trees to trees, we can naturally compose our algorithm with a parser P to form a function A o P from strings to trees whose dependency interpretation is, hopefully, an improvement over the trees from P. To test this idea quantitatively we evaluate performance with respect to recovery of typed dependency relations between words.",
                    "sid": 74,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A dependency relation, commonly employed for evaluation in the statistical parsing literature, is defined at a node N of a lexicalized parse tree as a pair (wi, wj) where wi is the lexical head of N and wj is the lexical head of some non-head daughter of N. Dependency relations may further be typed according to information at or near the relevant tree node; Collins (1999), for example, reports dependency scores typed on the syntactic categories of the mother, head daughter, and dependent daughter, plus on whether the dependent precedes or follows the head.",
                    "sid": 75,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We present here dependency evaluations where the gold-standard dependency set is defined by the remapped tree, typed gory of null insertions, whereas previous work has; as a result, the null complementizer class 0 and WH-t dislocation class are aggregates of classes used in previous work. by syntactic category of the mother node.12 In Figure 1, for example, to would be an ADJP dependent of quick rather than a VP dependent of was; and Farmers would be an S dependent both of to in to point out ... and of was.",
                    "sid": 76,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We use the head-finding rules of Collins (1999) to lexicalize trees, and assume that null complementizers do not participate in dependency relations.",
                    "sid": 77,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To further compare the results of our algorithm with previous work, we obtained the output trees produced by Johnson (2002) and Dienes (2003) and evaluated them on typed dependency performance.",
                    "sid": 78,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 3 shows the results of this evaluation.",
                    "sid": 79,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For comparison, we include shallow dependency accuracy for Charniak\u2019s parser under PCF.",
                    "sid": 80,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In order to compare the results of nonlocal dependency reconstruction between languages, we must identify equivalence classes of nonlocal dependency annotation between treebanks.",
                    "sid": 81,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "NEGRA\u2019s nonlocal dependency annotation is quite different from WSJ, as described in Section 2, ignoring controlled and arbitrary unexpressed subjects.",
                    "sid": 82,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The natural basis of comparison is therefore the set of all nonlocal NEGRA annotations against all WSJ dislocations, excluding relativizations (defined simply as dislocated wh- constituents under SBAR).13 Table 4 shows the performance comparison between WSJ and NEGRA of IDENTDISLOC and RELOCMOVED, on sentences of 40 tokens or less.",
                    "sid": 83,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For this evaluation metric we use syntactic category and left & right edges of (1) dislocated nodes (ID); and (2) originating mother node to which dislocated node is mapped (Rel).",
                    "sid": 84,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Combo requires both (1) and (2) to be correct.",
                    "sid": 85,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "NEGRA is smaller than WSJ (\u223c350,000 words vs. 1 million), so for fair comparison we tested WSJ using the smaller training set described in Section 2, comparable in size to NEGRA\u2019s.",
                    "sid": 86,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since the positioning of traces within NEGRA nodes is trivial, we evaluate remapping and combination performances requiring only proper selection of the originating mother node; thus we carry the algorithm out on both treebanks through step (2b).",
                    "sid": 87,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is adequate for purposes of our typed dependency evaluation in Section 4.2, since typed dependencies do not depend on positional information.",
                    "sid": 88,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "State-of-the-art statistical parsing is far better on WSJ (Charniak, 2000) than on NEGRA (Dubey and Keller, 2003), so for comparison of parser-composed dependency performance we used vanilla PCFG models for both WSJ and NEGRA trained on comparably-sized datasets; in addition to making similar types of independence assumptions, these models performed relatively comparably on labeled bracketing measures for our development sets (73.2% performance for WSJ versus 70.9% for NEGRA).",
                    "sid": 89,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table 5 compares the testset performance of algorithms on the two treebanks on the typed dependency measure introduced in Section 4.2.14",
                    "sid": 90,
                    "ssid": 21,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "5 discussion",
            "number": "5",
            "sents": [
                {
                    "text": "The WSJ results shown in Tables 2 and 3 suggest that discriminative models incorporating both nonlocal and local lexical and syntactic information can achieve good results on the task of non-local dependency identification.",
                    "sid": 91,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the PARSEVAL metric, our algorithm performed particularly well on null complementizer and control locus insertion, and on S node relocation.",
                    "sid": 92,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In particular, Johnson noted that the proper insertion of control loci was a difficult issue involving lexical as well as structural sensitivity.",
                    "sid": 93,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We found the loglinear paradigm a good one in which to model this feature combination; when run in isolation on gold-standard development trees, our model reached 96.4% F1 on control locus insertion, reducing error over the Johnson model\u2019s 89.3% 14Many head-dependent relations in NEGRA are explicitly marked, but for those that are not we used a Collins (1999)style head-finding algorithm independently developed for German PCFG parsing. by nearly two-thirds.",
                    "sid": 94,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The performance of our algorithm is also evident in the substantial contribution to typed dependency accuracy seen in Table 3.",
                    "sid": 95,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For gold-standard input trees, our algorithm reduces error by over 80% from the surface-dependency baseline, and over 60% compared with Johnson\u2019s results.",
                    "sid": 96,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For parsed input trees, our algorithm reduces dependency error by 23% over the baseline, and by 5% compared with Johnson\u2019s results.",
                    "sid": 97,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that the dependency figures of Dienes lag behind even the parsed results for Johnson\u2019s model; this may well be due to the fact that Dienes built his model as an extension of Collins (1999), which lags behind Charniak (2000) by about 1.3-1.5%.",
                    "sid": 98,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Manual investigation of errors on English goldstandard data revealed two major issues that suggest further potential for improvement in performance without further increase in algorithmic complexity or training set size.",
                    "sid": 99,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "First, we noted that annotation inconsistency accounted for a large number of errors, particularly false positives.",
                    "sid": 100,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "VPs from which an S has been extracted ([SShut up,] he [VP said t]) are inconsistently given an empty SBAR daughter, suggesting the cross-model low-70\u2019s performance on null SBAR insertion models (see Table 2) may be a ceiling.",
                    "sid": 101,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Control loci were often under-annotated; the first five development-set false positive control loci we checked were all due to annotation error.",
                    "sid": 102,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "And why-WHADVPs under SBAR, which are always dislocations, were not so annotated 20% of the time.",
                    "sid": 103,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Second, both control locus insertion and dislocated NP remapping must be sensitive to the presence of argument NPs under classified nodes.",
                    "sid": 104,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "But temporal NPs, indistinguishable by gross category, also appear under such nodes, creating a major confound.",
                    "sid": 105,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We used customized features to compensate to some extent, but temporal annotation already exists in WSJ and could be used.",
                    "sid": 106,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We note that Klein and Manning (2003) independently found retention of temporal NP marking useful for PCFG parsing.",
                    "sid": 107,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As can be seen in Table 3, the absolute improvement in dependency recovery is smaller for both our and Johnson\u2019s postprocessing algorithms when applied to parsed input trees than when applied to gold-standard input trees.",
                    "sid": 108,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It seems that this degradation is not primarily due to noise in parse tree outputs reducing recall of nonlocal dependency identification: precision/recall splits were largely the same between gold and parsed data, and manual inspection revealed that incorrect nonlocal dependency choices often arose from syntactically reasonable yet incorrect input from the parser.",
                    "sid": 109,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, the gold-standard parse right-wing whites ... will [VP step up [NP their threats [S [VP * to take matters into their own hands ]]]] has an unindexed control locus because Treebank annotation specifies that infinitival VPs inside NPs are not assigned controllers.",
                    "sid": 110,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Charniak\u2019s parser, however, attaches the infinitival VP into the higher step up ... VP.",
                    "sid": 111,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Infinitival VPs inside VPs generally do receive controllers for their null subjects, and our algorithm accordingly yet mistakenly assigns right-wing-whites as the antecedent.",
                    "sid": 112,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The English/German comparison shown in Tables 4 and 5 is suggestive, but caution is necessary in its interpretation due to the fact that differences in both language structure and treebank annotation may be involved.",
                    "sid": 113,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Results in the G column of Table 5, showing the accuracy of the context-free dependency approximation from gold-standard parse trees, quantitatively corroborates the intuition that nonlocal dependency is more prominent in German than in English.",
                    "sid": 114,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Manual investigation of errors made on German gold-standard data revealed two major sources of error beyond sparsity.",
                    "sid": 115,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The first was a widespread ambiguity of S and VP nodes within S and VP nodes; many true dislocations of all sorts are expressed at the S and VP levels in CFG parse trees, such as VP1 of Figure 2, but many adverbial and subordinate phrases of S or VP category are genuine dependents of the main clausal verb.",
                    "sid": 116,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We were able to find a number of features to distinguish some cases, such as the presence of certain unambiguous relativeclause introducing complementizers beginning an S node, but much ambiguity remained.",
                    "sid": 117,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second was the ambiguity that some matrix S-initial NPs are actually dependents of the VP head (in these cases, NEGRA annotates the finite verb as the head of S and the non-finite verb as the head of VP).",
                    "sid": 118,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is not necessarily a genuine discontinuity per se, but rather corresponds to identification of the subject NP in a clause.",
                    "sid": 119,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Obviously, having access to reliable case marking would improve performance in this area; such information is in fact included in NEGRA\u2019s morphological annotation, another argument for the utility of involving enhanced annotation in CF parsing.",
                    "sid": 120,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As can be seen in the right half of Table 4, performance falls off considerably on vanilla PCFGWSJ(full) WSJ(sm) NEGRA parsed data.",
                    "sid": 121,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This fall-off seems more dramatic than that seen in Sections 4.1 and 4.2, no doubt partly due to the poorer performance of the vanilla PCFG, but likely also because only non-relativization dislocations are considered in Section 4.3.",
                    "sid": 122,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These dislocations often require non-local information (such as identity of surface lexical governor) for identification and are thus especially susceptible to degradation in parsed data.",
                    "sid": 123,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Nevertheless, seemingly dismal performance here still provided a strong boost to typed dependency evaluation of parsed data, as seen in A \u25e6 P of Table 5.",
                    "sid": 124,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We suspect this indicates that dislocated terminals are being usefully identified and mapped back to their proper governors, even if the syntactic projections of these terminals and governors are not being correctly identified by the parser.",
                    "sid": 125,
                    "ssid": 35,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "6 further work",
            "number": "6",
            "sents": [
                {
                    "text": "Against the background of CFG as the standard approximation of dependency structure for broadcoverage parsing, there are essentially three options for the recovery of nonlocal dependency.",
                    "sid": 126,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The first option is to postprocess CF parse trees, which we have closely investigated in this paper.",
                    "sid": 127,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second is to incorporate nonlocal dependency information into the category structure of CF trees.",
                    "sid": 128,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This was the approach taken by Dienes and Dubey (2003a,b) and Dienes (2003); it is also practiced in recent work on broad-coverage CCG parsing (Hockenmaier, 2003).",
                    "sid": 129,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The third would be to incorporate nonlocal dependency information into the edge structure parse trees, allowing discontinuous constituency to be explicitly represented in the parse chart.",
                    "sid": 130,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This approach was tentatively investigated by Plaehn (2000).",
                    "sid": 131,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As the syntactic diversity of languages for which treebanks are available grows, it will become increasingly important to compare these three approaches.",
                    "sid": 132,
                    "ssid": 7,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "7 acknowledgements",
            "number": "7",
            "sents": [
                {
                    "text": "This work has benefited from feedback from Dan Jurafsky and three anonymous reviewers, and from presentation at the Institute of Cognitive Science, University of Colorado at Boulder.",
                    "sid": 133,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The authors are also grateful to Dan Klein and Jenny Finkel for use of maximum-entropy software they wrote.",
                    "sid": 134,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This work was supported in part by the Advanced Research and Development Activity (ARDA)\u2019s Advanced Question Answering for Intelligence (AQUAINT) Program.",
                    "sid": 135,
                    "ssid": 3,
                    "kind_of_tag": "s"
                }
            ]
        }
    ]
}