{
    "ID": "N10-1035",
    "sections": [
        {
            "text": "abstract",
            "number": 0,
            "sents": [
                {
                    "text": "Efficient Parsing of Well-Nested Linear Context-Free Rewriting Systems",
                    "sid": 0,
                    "ssid": null,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The use of well-nested linear context-free rewriting systems has been empirically motivated for modeling of the syntax of languages with discontinuous constituents or relatively free word order.",
                    "sid": 1,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We present a chart-based parsing algorithm that asymptotically improves the known running time upper bound for this class of rewriting systems.",
                    "sid": 2,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our result is obtained through a linear space construction of a binary normal form for the grammar at hand.",
                    "sid": 3,
                    "ssid": 3,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "1 introduction",
            "number": "1",
            "sents": [
                {
                    "text": "Since its earliest years, one of the main goals of computational linguistics has been the modeling of natural language syntax by means of formal grammars.",
                    "sid": 4,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Following results by Huybregts (1984) and Shieber (1985), special attention has been given to formalisms that enlarge the generative power of context-free grammars, but still remain below the full generative power of context-sensitive grammars.",
                    "sid": 5,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On this line of investigation, mildly context-sensitive grammar formalisms have been introduced (Joshi, 1985), including, among several others, the tree adjoining grammars (TAGs) of Joshi et al. (1975).",
                    "sid": 6,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Linear context-free rewriting system (LCFRS), introduced by Vijay-Shanker et al. (1987), is a mildly context-sensitive formalism that allows the derivation of tuples of strings, i.e., discontinuous phrases.",
                    "sid": 7,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This feature has been used to model phrase structure treebanks with discontinuous constituents (Maier and S\u00f8gaard, 2008), as well as to map non-projective dependency trees into discontinuous phrase structures (Kuhlmann and Satta, 2009).",
                    "sid": 8,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Informally, in an LCFRS G, each nonterminal can generate string tuples with a fixed number of components.",
                    "sid": 9,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The fan-out of G is defined as the maximum number of tuple components generated by G. During a derivation of an LCFRS, tuple components generated by the nonterminals in the right-hand side of a production are concatenated to form new tuples, possibly adding some terminal symbols.",
                    "sid": 10,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The only restriction applying to these generalized concatenation operations is linearity, that is, components cannot be duplicated or deleted.",
                    "sid": 11,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The freedom in the rearrangement of components has specific consequences in terms of the computational and descriptional complexity of LCFRS.",
                    "sid": 12,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Even for grammars with bounded fan-out, the universal recognition problem is NP-hard (Satta, 1992), and these systems lack Chomsky-like normal forms for fixed fan-out (Rambow and Satta, 1999) that are especially convenient in tabular parsing.",
                    "sid": 13,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is in contrast with other mildly context-sensitive formalisms, and TAG in particular: TAGs can be parsed in polynomial time both with respect to grammar size and string size, and they can be cast in normal forms having binary derivation trees only.",
                    "sid": 14,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It has recently been argued that LCFRS might be too powerful for modeling languages with discontinuous constituents or with relatively free word order, and that additional restrictions on the rearrangement of components might be needed.",
                    "sid": 15,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "More specifically, analyses of both dependency and constituency treebanks (Kuhlmann and Nivre, 2006; Havelka, 2007; Maier and Lichte, 2009) have shown that rearrangements of argument tuples almost always satisfy the so-called well-nestedness condition, a generalization of the standard condition on balanced brackets.",
                    "sid": 16,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This condition states that any two components x1, x2 of some tuple will never be composed with any two components y1, y2 of some other tuple in such a way that a \u2018crossing\u2019 configuration is realized.",
                    "sid": 17,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this paper, we contribute to a better understanding of the formal properties of well-nested LCFRS.",
                    "sid": 18,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We show that, when fan-out is bounded by any integer \u03d5 \u2265 1, these systems can always be transformed, in an efficient way, into a specific normal form with no more than two nonterminals in their productions\u2019 right-hand sides.",
                    "sid": 19,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the basis of this result, we then develop an efficient parsing algorithm for wellnested LCFRS, running in time O(\u03d5 \u00b7 |G |\u00b7 |w|2\u03d5+2), where G and w are the input grammar and string, respectively.",
                    "sid": 20,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Well-nested LCFRS with fan-out \u03d5 = 2 are weakly equivalent to TAG, and our complexity result reduces to the well-known upper bound O(|G |\u00b7 |w|6) for this class.",
                    "sid": 21,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For \u03d5 > 2, our upper bound is asymptotically better than the one obtained from existing parsing algorithms for general LCFRS or equivalent formalisms (Seki et al., 1991).",
                    "sid": 22,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Well-nested LCFRS are generatively equivalent to (among others) coupled context-free grammars (CCFG), introduced by Hotz and Pitsch (1996).",
                    "sid": 23,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These authors also provide a normal form and develop a parsing algorithm for CCFGs.",
                    "sid": 24,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "One difference with respect to our result is that the normal form for CCFGs allows more than two nonterminals to appear in the right-hand side of a production, even though no nonterminal may contribute more than two tuple components.",
                    "sid": 25,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Also, the construction in (Hotz and Pitsch, 1996) results in a blow-up of the grammar that is exponential in its fan-out, and the parsing algorithm that is derived runs in time O(4\u03d5 \u00b7 |G |\u00b7 |w|2\u03d5+2).",
                    "sid": 26,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our result is therefore a considerable asymptotic improvement over the CCFG result, both with respect to the normal form construction and the parsing efficiency.",
                    "sid": 27,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Finally, under a practical perspective, our parser is a simple chart-based algorithm, while the algorithm in (Hotz and Pitsch, 1996) involves two passes and is considerably more complex to analyze and to implement than ours.",
                    "sid": 28,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Kanazawa and Salvati (2010) mention a normal form for well-nested multiple context-free grammars.",
                    "sid": 29,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Structure In Section 2, we introduce LCFRS and the class of well-nested LCFRS that is the focus of this paper.",
                    "sid": 30,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In Section 3, we discuss the parsing complexity of LCFRS, and show why grammars using our normal form can be parsed efficiently.",
                    "sid": 31,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Section 4 presents the transformation of a well-nested LCFRS into the normal form.",
                    "sid": 32,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Section 5 concludes the paper.",
                    "sid": 33,
                    "ssid": 30,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "2 linear context-free rewriting systems",
            "number": "2",
            "sents": [
                {
                    "text": "We write [n] to denote the set of positive integers up to and including n: [n] = {1, ... , n}.",
                    "sid": 34,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let \u03a3 be an alphabet.",
                    "sid": 35,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For integers m \u2265 0 and k1, ... , km, k \u2265 1, a total function is called a linear, non-erasing function over \u03a3 with type k1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 km \u2192 k, if it can be defined by an equation of the form f(hx1,1, ... , x1,k1i, ... , hxm,1, ..., xm,kmi) = \u03b1~ , where \u03b1~ is a k-tuple of strings over the variables on the left-hand side of the equation and \u03a3 with the property that each variable occurs in \u03b1~ exactly once.",
                    "sid": 36,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The values m and k are called the rank and the fanout of f, and denoted by \u03c1(f) and \u03d5(f).",
                    "sid": 37,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For the purposes of this paper, a linear context-free rewriting system, henceforth LCFRS, is a construct G = (N, T, P, S), where N is an alphabet of nonterminal symbols in which each symbol A is associated with a positive integer \u03d5(A) called its fan-out, T is an alphabet of terminal symbols, S \u2208 N is a distinguished start symbol with \u03d5(S) = 1; and P is a finite set of productions of the form where m \u2265 0, A, A1, ... , Am \u2208 N, and f is a linear, non-erasing function over the terminal alphabet T with type \u03d5(A1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 \u03d5(Am) \u2192 \u03d5(A), called the composition operation associated with p. The rank of G and the fan-out of G are defined as the maximal rank and fan-out of the composition operations of G, and are denoted by \u03c1(G) and \u03d5(G).",
                    "sid": 38,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The sets of derivation trees of G are the smallest indexed family of sets DA, A \u2208 N, such that, if is a production of G and ti E DAi for all i E [m], then t = p(t1, ... , tm) E DA.",
                    "sid": 39,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By interpreting productions as their associated composition operations in the obvious way, a derivation tree t E DA evaluates to a cp(A)-tuple of strings over T; we denote this tuple by val(t).",
                    "sid": 40,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The string language generated by G, denoted by L(G), is then defined as Two LCFRS are called weakly equivalent, if they generate the same string language.",
                    "sid": 41,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Example Figure 1 shows a sample LCFRS G with p(G) = 1 and cp(G) = 2.",
                    "sid": 42,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The sets of its derivation trees are DR = { pn2(p3)  |n > 0 } and DS = { p1(t)  |t E DR }.",
                    "sid": 43,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The string language generated by G is { anbncndn  |n > 0 }.",
                    "sid": 44,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the remainder of this paper, we use the following convenient syntax for tuples of strings.",
                    "sid": 45,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Instead of using the $-symbol to mark the component boundaries.",
                    "sid": 46,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We call this the characteristic string of the tuple, and an occurrence of the symbol $ a gap marker.",
                    "sid": 47,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We also use this notation for composition operations.",
                    "sid": 48,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, the characteristic string of the operation is a x1,1 x2,1 $ x1,2 b.",
                    "sid": 49,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "If we assume the variables on the left-hand side of an equation to be named according to the schema used in Section 2.1, then the characteristic string of a composition operation determines that operation completely.",
                    "sid": 50,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will therefore freely identify the two, and write productions as where the string inside the brackets is the characteristic string of some composition operation.",
                    "sid": 51,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The substrings v1, ... , vk are called the components of the characteristic string.",
                    "sid": 52,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that the characteristic string of a composition operation with type k1 x \u00b7 \u00b7 \u00b7 x km \u2014* k is a sequence of terminal symbols, gap markers, and variables from the set { xi,j  |i E [m], j E [ki] } in which the number of gap markers is k\u22121, and each variable occurs exactly once.",
                    "sid": 53,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "When in the context of such a composition operation we refer to \u2018a variable of the form xi,j\u2019, then it will always be the case that i E [m] and j E [ki].",
                    "sid": 54,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The identification of composition operations and their characteristic strings allows us to construct new operations by string manipulations: if, for example, we delete some variables from a characteristic string, then the resulting string still defines a composition operation (after a suitable renaming of the remaining variables, which we leave implicit).",
                    "sid": 55,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To simplify our presentation, we will assume that LCFRS are given in a certain canonical form.",
                    "sid": 56,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Intuitively, this canonical form requires the variables in the characteristic string of a composition operation to be ordered in a certain way.",
                    "sid": 57,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Formally, the defining equation of a composition operation f with type k1 x \u00b7 \u00b7 \u00b7 x km \u2014* k is called canonical, if (i) the sequence obtained from f by reading variables of the form xi,1 from left to right has the form x1,1 \u00b7 \u00b7 \u00b7 xm,1; and (ii) for each i E [m], the sequence obtained from f by reading variables of the form xi,j from left to right has the form xi,1 \u00b7 \u00b7 \u00b7 xi,ki.",
                    "sid": 58,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An LCFRS is called canonical, if each of its composition operations is canonical.",
                    "sid": 59,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We omit the proof that every LCFRS can be transformed into a weakly equivalent canonical LCFRS.",
                    "sid": 60,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, we point out that both the normal form and the parsing algorithm that we present in this paper can be applied also to general LCFRS.",
                    "sid": 61,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is in contrast to some left-to-right parsers in the literature on LCFRS and equivalent formalisms (de la Clergerie, 2002; Kallmeyer and Maier, 2009), which actually depend on productions in canonical form.",
                    "sid": 62,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We now characterize the class of well-nested LCFRS that are the focus of this paper.",
                    "sid": 63,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Well-nestedness was first studied in the context of dependency grammars (Kuhlmann and M\u00f6hl, 2007).",
                    "sid": 64,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Kanazawa (2009) defines well-nested multiple context-free grammars, which are weakly equivalent to well-nested LCFRS.",
                    "sid": 65,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A composition operation is called well-nested, if it does not contain a substring of the form For example, the operation x1,1 x2,1$x2,2 x1,2 is wellnested, while x1,1 x2,1 $ x1,2 x2,2 is not.",
                    "sid": 66,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An LCFRS is called well-nested, if it contains only well-nested composition operations.",
                    "sid": 67,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The class of languages generated by well-nested LCFRS is properly included in the class of languages generated by general LCFRS; see Kanazawa and Salvati (2010) for further discussion.",
                    "sid": 68,
                    "ssid": 35,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "3 parsing lcfrs",
            "number": "3",
            "sents": [
                {
                    "text": "We now discuss the parsing complexity of LCFRS, and motivate our interest in a normal form for wellnested LCFRS.",
                    "sid": 69,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A bottom-up, chart-based parsing algorithm for the class of (not necessarily well-nested) LCFRS can be defined by using the formalism of parsing schemata (Sikkel, 1997).",
                    "sid": 70,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The parsing schemata approach considers parsing as a deduction process (as in Shieber et al. (1995)), generating intermediate results called items.",
                    "sid": 71,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Starting with an initial set of items obtained from each input sentence, a parsing schema defines a set of deduction steps that can be used to infer new items from existing ones.",
                    "sid": 72,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each item contains information about the sentence\u2019s structure, and a successful parsing process will produce at least one final item containing a full parse for the input.",
                    "sid": 73,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The item set used by our bottom-up algorithm to parse an input string w = a1 \u00b7 \u00b7 \u00b7 an with an LCFRS where an item [A, (l1, r1), ... , (lk, rk)] can be interpreted as the set of those derivation trees t \u2208 DA of G for which val(t) = al1+1 \u00b7\u00b7\u00b7 ar1 $ \u00b7\u00b7\u00b7 $ alk+1 \u00b7\u00b7\u00b7 ark .",
                    "sid": 74,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The set of final items is thus F = {[S, (0, n)]}, containing full derivation trees that evaluate to w. For simplicity of definition of the sets of initial items and deduction steps, let us assume that productions of rank > 0 in our grammar do not contain terminal symbols in their right-hand sides.",
                    "sid": 75,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This can be easily achieved from a starting grammar by creating a nonterminal Aa for each terminal a \u2208 T, a corresponding rank-0 production pa = Aa \u2192 [a](), and then changing each occurrence of a in the characteristic string of a production to the single variable associated with the fan-out 1 nonterminal Aa.",
                    "sid": 76,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "With this, our initial item set for a string a1 \u00b7 \u00b7 \u00b7 an will be and each production p = A0 \u2192 f(A1,..., Am) of G (excluding the ones we created for the terminals) will produce a deduction step of the form given in Figure 2a, where the indexes are subject to the following constraints, imposed by the semantics of f. The time complexity of parsing LCFRS with respect to the length of the input can be analyzed by counting the maximum number of indexes that can appear in an instance of the inference rule above.",
                    "sid": 77,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Although the total number of indexes is Emi= 2 \u00b7 \u03d5(Ai), some of 0 these indexes are equated by the constraints.",
                    "sid": 78,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To count the number of independent indexes, consider all the indexes of the form l0,i (corresponding to the left endpoints of each component of the characteristic string of f) and those of the form rj,k for j > 0 (corresponding to the right endpoints of each variable in the characteristic string).",
                    "sid": 79,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By the constraints above, these indexes are mutually independent, and it is easy to check that any other index is equated to one of these: indexes r0,i are equated to the index rj,k corresponding to the last variable xj,k of the ith component of the characteristic string, or to l0,i if there is no such variable; while indexes lj,k with j > 0 are equated to an index l0,i if the variable xj,k is at the beginning of a component of the characteristic string, or to an index rj0,k0(j' > 1) if the variable xj,k follows another variable xj0,k0.",
                    "sid": 80,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Thus, the parsing complexity (Gildea, 2010) of a production p = A0 \u2192 f(A1, ... , Am) is determined by \u03d5(A0) l-indexes and i\u2208[m]\u03d5(Ai) r-indexes, for a total complexity of where |w |is the length of the input string.",
                    "sid": 81,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The parsing complexity of an LCFRS will correspond to the maximum parsing complexity among its productions.",
                    "sid": 82,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that this general complexity matches the result given by Seki et al. (1991).",
                    "sid": 83,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In an LCFRS of rank \u03c1 and fan-out \u03d5, the maximum possible parsing complexity is O(|w|\u03d5(\u03c1+1)), obtained by applying the above expression to a production of rank \u03c1 and where each nonterminal has fanout \u03d5.",
                    "sid": 84,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The asymptotic time complexity of LCFRS parsing is therefore exponential both in its rank and its fan-out.",
                    "sid": 85,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This means that it is interesting to transform LCFRS into equivalent forms that reduce their rank while preserving the fan-out.",
                    "sid": 86,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For sets of LCFRS that can be transformed into a binary form (i.e., such that all its rules have rank at most 2), the \u03c1 factor in the complexity is reduced to a constant, and complexity is improved to O(|w|3\u03d5) (see G\u00f3mez-Rodr\u00edguez et al. (2009) for further discussion).",
                    "sid": 87,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Unfortunately, it is known by previous results (Rambow and Satta, 1999) that it is not always possible to convert an LCFRS into such a binary form without increasing the fan-out.",
                    "sid": 88,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, we will show that it is always possible to build such a binarization for well-nested LCFRS.",
                    "sid": 89,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Combining this result with the inference rule and complexity analysis given above, we would obtain a parser for well-nested LCFRS running in O(|w|3\u03d5) time.",
                    "sid": 90,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "But the construction of our binary normal form additionally restricts binary composition operations in the binarized LCFRS to be of two specific forms, concatenation and wrapping, which further improves the parsing complexity to O(|w|2\u03d5+2), as we will see below.",
                    "sid": 91,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A composition operation is called a concatenation operation, if its characteristic string has the form x1,1 $ \u00b7\u00b7\u00b7 $ x1,m x2,1 $ \u00b7\u00b7\u00b7 $ x2,n , where m, n \u2265 1.",
                    "sid": 92,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Intuitively, such an operation corresponds to the bottom-up combination of two adjacent discontinuous constituents into one.",
                    "sid": 93,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An example of a concatenation operation is the binary parsing rule used by the standard CKY parser for context-free grammars, which combines continuous constituents (represented as 1-tuples of strings in the LCFRS notation).",
                    "sid": 94,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the general case, a concatenation operation will take an m-tuple and an n-tuple and return an (m + n \u2212 1)-tuple, as the joined constituents may have gaps that will also appear in the resulting tuple.",
                    "sid": 95,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "If we apply the general parsing rule given in Figure 2a to a production A \u2192 conc(B, C), where conc is a concatenation operation, then we obtain the deduction step given in Figure 2b.",
                    "sid": 96,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This step uses 2m different l- and r-indexes, and 2n \u2212 1 different l0and r0-indexes (excluding l01 which must equal rm), for a total of 2m+2n\u22121 = 2(m+n\u22121)+1 indexes.",
                    "sid": 97,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since m + n \u2212 1 is the fan-out of the nonterminal A, we conclude that the maximum number of indexes in the step associated with a concatenation operation in an LCFRS of fan-out \u03d5 is 2\u03d5 + 1.",
                    "sid": 98,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A linear, non-erasing function is called a wrapping operation, if its characteristic string has the form where m, n > 1 and i E [m \u22121].",
                    "sid": 99,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Intuitively, such an operation wraps the tuple derived from a nonterminal B around the tuple derived from a nonterminal C, filling the ith gap in the former.",
                    "sid": 100,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An example of a wrapping operation is the adjunction of an auxiliary tree in tree-adjoining grammar.",
                    "sid": 101,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the general case, a wrapping operation will take an m-tuple and an n-tuple and return an (m + n \u2212 2)-tuple of strings: the gaps of the argument tuples appear in the obtained tuple, except for one gap in the tuple derived from B which is filled by the tuple derived from C. By applying the general parsing rule in Figure 2a to a production A \u2014* wrapi(B, C), where wrapi is a wrapping operation, then we obtain the deduction step given in Figure 2c.",
                    "sid": 102,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This step uses 2m different land r-indexes, and 2n \u2212 2 different l0- and r0-indexes (discounting l01 and r0n which are equal to other indexes), for a total of 2m+2n\u22122 = 2(m+n\u22122)+2 indexes.",
                    "sid": 103,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since the fan-out of A is m + n \u2212 2, this means that a wrapping operation needs at most 2cp+2 indexes for an LCFRS of fan-out cp.",
                    "sid": 104,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "From this, we conclude that an LCFRS of fanout cp in which all composition operations are either concatenation operations, wrapping operations, or operations of rank 0 or 1, can be parsed in time O(|w|2\u03d5+2).",
                    "sid": 105,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In particular, nullary and unary composition operations do not affect this worst-case complexity, since their associated deduction steps can never have more than 2cp indexes.",
                    "sid": 106,
                    "ssid": 38,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "4 transformation",
            "number": "4",
            "sents": [
                {
                    "text": "We now show how to transform a well-nested LCFRS into the normal form that we have just described.",
                    "sid": 107,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Consider a production p = A \u2014* f(A1,..., Am), where m > 2 and f is neither a concatenation nor a wrapping operation.",
                    "sid": 108,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We will construct new productions p0, q, r such that every derivation that uses p can be rewritten into a derivation that uses the new productions, and the new productions do not license any other derivations.",
                    "sid": 109,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Formally, this can be understood as implementing a tree transformation, where the input trees are derivations of the original grammar, and the output trees are derivations of the new grammar.",
                    "sid": 110,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The situation is illustrated in Figure 3.",
                    "sid": 111,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The tree on top represents a derivation in the original grammar; this derivation starts with the rewriting of the nonterminal A using the production p, and continues with the subderivations t1, ... , tm.",
                    "sid": 112,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The tree at the bottom represents a derivation in the transformed grammar.",
                    "sid": 113,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This derivation starts with the rewriting of A using the new production p0, and continues with two independent subderivations that start with the new productions q and r, respectively.",
                    "sid": 114,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The sub-derivations t1, ... , tm have been partitioned into two sequences t1,1, ... ,t1,m1 and t2,1, ... ,t2,m2 .",
                    "sid": 115,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The new production p0 will be either a concatenation or a wrapping operation, and the rank of both q and r will be strictly smaller than the rank of p. The transformation will continue with q and r, unless these have rank one.",
                    "sid": 116,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By applying this strategy exhaustively, we will thus eventually end up with a grammar that only has productions with rank at most 2, and in which all productions with rank 2 are either concatenation or wrapping operations.",
                    "sid": 117,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To transform the production p, we first factorize the composition operation f associated with p into three new composition operations f0, g, h as follows.",
                    "sid": 118,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Recall that we represent composition operations by their characteristic strings.",
                    "sid": 119,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the following, we will assume that no characteristic string starts or ends with a gap marker, or contains immediate repetitions of gap markers.",
                    "sid": 120,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This property can be ensured, without affecting the asymptotic complexity, by adding intermediate steps to the transformation that we report here; we omit the details due to space reasons.",
                    "sid": 121,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "When this property holds, we are left with the following two cases.",
                    "sid": 122,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let us call a sequence of variables joint, if it contains all and only variables associated with a given nonterminal.",
                    "sid": 123,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Case 1 f = x1 f1 x2 \u00b7\u00b7\u00b7 xk\u22121 fk\u22121 xk f* , where k > 1, x1, ... , xk are joint variables, and the suffix f* contains at least one variable.",
                    "sid": 124,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let let h = f*, and let f' = conc.",
                    "sid": 125,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As f is well-nested, both g and h define well-nested composition operations.",
                    "sid": 126,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By the specific segmentation of f, the ranks of these operations are strictly smaller than the rank of f. Furthermore, we have \u03d5(f) = \u03d5(g) + \u03d5(h) \u2014 1.",
                    "sid": 127,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Case 2 f = x1 f1 x2 \u00b7 \u00b7 \u00b7 xk\u22121 fk\u22121 xk , where k > 2, x1, ... , xk are joint variables, and there exist at least one i such that the sequence fi contains at least one variable.",
                    "sid": 128,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Choose an index j as follows: if there is at least one i such that fi contains at least one variable and one gap marker, let j be the minimal such i; otherwise, let j be the minimal i such that fi contains at least one variable.",
                    "sid": 129,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Now, let let h = fj, and let f' = wrapj.",
                    "sid": 130,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As in Case 1, both g and h define well-nested composition operations whose ranks are strictly smaller than the rank of f. Furthermore, we have \u03d5(f) = \u03d5(g) + \u03d5(h) \u2014 2.",
                    "sid": 131,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Note that at most one of the two cases can apply to f. Furthermore, since f is well-nested, it is also true that at least one of the two cases applies.",
                    "sid": 132,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is so because for two distinct nonterminals Ai, AiA, either all variables associated with AiA precede the leftmost variable associated with Ai, succeed the rightmost variable associated with Ai, or are placed between two variables associated with Ai without another variable associated with Ai intervening.",
                    "sid": 133,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "(Here, we have left out the symmetric cases.)",
                    "sid": 134,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Based on the composition operations, we now construct three new productions p', q, r as follows.",
                    "sid": 135,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let B and C be two fresh nonterminals with \u03d5(B) = \u03d5(g) and \u03d5(C) = \u03d5(h), and let p' = A \u2014 f'(B, C).",
                    "sid": 136,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The production p' rewrites A into B and C and combines the two subderivations that originate at these nonterminals using either a concatenation or a wrapping operation.",
                    "sid": 137,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Now, let Aq,1, ... , Aq,m9 and Ar,1, .",
                    "sid": 138,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": ".",
                    "sid": 139,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": ".",
                    "sid": 140,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": ", Ar,m,. be the sequences of nonterminals that are obtained from the sequence A1, ... , Am by deleting those nonterminals that are not associated with any variable in g or h, respectively.",
                    "sid": 141,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Then, let We now illustrate the transformation using the concrete production p = A \u2014 f(A1, A2, A3), where Note that this operation has rank 3 and fan-out 3.",
                    "sid": 142,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The composition operations are constructed as follows.",
                    "sid": 143,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The operation f matches the pattern of Case 1, and hence induces the operations where B1 and C1 are fresh nonterminals with fanout 2.",
                    "sid": 144,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The production r1 has rank one, so it does not require any further transformations.",
                    "sid": 145,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The transformation thus continues with q1.",
                    "sid": 146,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The operation g1 matches the pattern of Case 2, and induces the operations g2 = x1,1 $ x1,2 , h2 = x2,1$, f'2 = wrap1 .",
                    "sid": 147,
                    "ssid": 41,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The productions constructed from these are where B2 and C2 are fresh nonterminals with fanout 2.",
                    "sid": 148,
                    "ssid": 42,
                    "kind_of_tag": "s"
                },
                {
                    "text": "At this point, the transformation terminates.",
                    "sid": 149,
                    "ssid": 43,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We can now delete p from the original grammar, and replace it with the productions {p'1, r1, p'2, q2, r2}.",
                    "sid": 150,
                    "ssid": 44,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To see that the transformation is correct, we need to verify that each production of the original grammar is transformed into a set of equivalent normal-form productions, and that the fan-out of the new grammar does not exceed the fan-out of the old grammar.",
                    "sid": 151,
                    "ssid": 45,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For the first point, we note that the transformation preserves well-nestedness, decreases the rank of a production, and is always applicable as long as the rank of a production is at most 2 and the production does not use a concatenation or wrapping operation.",
                    "sid": 152,
                    "ssid": 46,
                    "kind_of_tag": "s"
                },
                {
                    "text": "That the new productions are equivalent to the old ones in the sense of Figure 3 can be proved by induction on the length of a derivation in the original and the new grammar, respectively.",
                    "sid": 153,
                    "ssid": 47,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Let us now convince ourselves that the fan-out of the new grammar does not exceed the fan-out of the old grammar.",
                    "sid": 154,
                    "ssid": 48,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This is clear in Case 1, where implies that both cp(g) \u2264 cp(f) and cp(h) \u2264 cp(f).",
                    "sid": 155,
                    "ssid": 49,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For Case 2, we reason as follows.",
                    "sid": 156,
                    "ssid": 50,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The fan-out of the operation h, being constructed from an infix of the characteristic string of the original operation f, is clearly bounded by the fan-out of f. For g, we have Now suppose that the index j was chosen according to the first alternative.",
                    "sid": 157,
                    "ssid": 51,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this case, cp(h) \u2265 2, and For the case where j was chosen according to the second alternative, cp(f) < k (since there are no immediate repetitions of gap markers), cp(h) = 1, and cp(g) \u2264 k. If we assume that each nonterminal is productive, then this means that the underlying LCFRS has at least one production with fan-out k or more; therefore, the fan-out of g does not increase the fan-out of the original grammar.",
                    "sid": 158,
                    "ssid": 52,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To conclude, we now briefly discuss the space complexity of the normal-form transformation.",
                    "sid": 159,
                    "ssid": 53,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We measure it in terms of the length of a production, defined as the length of its string representation, that is, the string A \u2192 [v1 $ \u00b7\u00b7\u00b7 $ vk](A1, ... , Am) .",
                    "sid": 160,
                    "ssid": 54,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Looking at Figure 3, we note that the normal-form transformation of a production p can be understood as the construction of a (not necessarily complete) binary-branching tree whose leaves correspond to the productions obtained by splitting the characteristic string of p and whose non-leaf nodes are labeled with concatenation and wrapping operations.",
                    "sid": 161,
                    "ssid": 55,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By construction, the sum of the lengths of leaf-node productions is O(|p|).",
                    "sid": 162,
                    "ssid": 56,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since the number of inner nodes of a binary tree with n leaves is bounded by n \u2212 1, we know that the tree has O(p(p)) inner nodes.",
                    "sid": 163,
                    "ssid": 57,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As these nodes correspond to concatenation and wrapping operations, each inner-node production has length O(cp(p)).",
                    "sid": 164,
                    "ssid": 58,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Thus, the sum of the lengths of the productions created from |p |is O(|p |+ p(p)cp(p)).",
                    "sid": 165,
                    "ssid": 59,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since the rank of a production is always smaller than its length, this is reduced to O(|p|cp(p)).",
                    "sid": 166,
                    "ssid": 60,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore, the size of the normal-form transformation of an LCFRS G of fan-out cp is O(cp|G|) in the worst case, and linear space in practice, since the fan-out is typically bounded by a small integer.",
                    "sid": 167,
                    "ssid": 61,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Taking the normal-form transformation into account, our parser therefore runs in time O(cp \u00b7 |G |\u00b7 |w|2cp+2) where |G |is the original grammar size.",
                    "sid": 168,
                    "ssid": 62,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "5 conclusion",
            "number": "5",
            "sents": [
                {
                    "text": "In this paper, we have presented an efficient parsing algorithm for well-nested linear context-free rewriting systems, based on a new normal form for this formalism.",
                    "sid": 169,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The normal form takes up linear space with respect to grammar size, and the algorithm is based on a bottom-up process that can be applied to any LCFRS, achieving O(cp \u00b7 |G |\u00b7 |w|2cp+2) time complexity when applied to LCFRS of fan-out cp in our normal form.",
                    "sid": 170,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This complexity is an asymptotic improvement over existing results for this class, both from parsers specifically geared to well-nested LCFRS or equivalent formalisms (Hotz and Pitsch, 1996) and from applying general LCFRS parsing techniques to the well-nested case (Seki et al., 1991).",
                    "sid": 171,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The class of well-nested LCFRS is an interesting syntactic formalism for languages with discontinuous constituents, providing a good balance between coverage of linguistic phenomena in natural language treebanks (Kuhlmann and Nivre, 2006; Maier and Lichte, 2009) and desirable formal properties (Kanazawa, 2009).",
                    "sid": 172,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our results offer a further argument in support of well-nested LCFRS: while the complexity of parsing general LCFRS depends on two dimensions (rank and fan-out), this bidimensional hierarchy collapses into a single dimension in the well-nested case, where complexity is only conditioned by the fan-out.",
                    "sid": 173,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Acknowledgments G\u00f3mez-Rodr\u00edguez has been supported by MEC/FEDER (HUM2007-66607-C04) and Xunta de Galicia (PGIDIT07SIN005206PR, Redes Galegas de PL e RI e de Ling. de Corpus, Bolsas Estad\u00edas INCITE/FSE cofinanced).",
                    "sid": 174,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Kuhlmann has been supported by the Swedish Research Council.",
                    "sid": 175,
                    "ssid": 7,
                    "kind_of_tag": "s"
                }
            ]
        }
    ]
}