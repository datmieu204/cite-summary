{
    "ID": "C00-2095",
    "sections": [
        {
            "text": "abstract",
            "number": 0,
            "sents": [
                {
                    "text": "Sumo is a formalism for universal segmentation of text.",
                    "sid": 1,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Its purpose is to provide a framework for the creation of segmentation applications.",
                    "sid": 2,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It is called \"universal\" as the formalism itself is independent of the language of the documents to process and independent of the levels of seg\u00ad mentation (e.g. words, sentences, paragraphs, morphemes...)",
                    "sid": 3,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "considered by the target applica\u00ad tion.",
                    "sid": 4,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This framework relies on a layered struc\u00ad ture representing the possible segmentations of the document.",
                    "sid": 5,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This structure and the tools to manipulate it arc described, followed by detailed examples highlighting some features of Sumo.",
                    "sid": 6,
                    "ssid": 6,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "introduction",
            "number": "1",
            "sents": [
                {
                    "text": "Tokenization, or word segmentation, is a fun\u00ad damental task of almost all NLP systems.",
                    "sid": 7,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In languages that use word separators in their writ\u00ad ing, tokenization seems easy: every sequence of characters between two whitespaces or punctu\u00ad ation marks is a word.",
                    "sid": 8,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This works reasonably well, but exceptions are handled in a cumber\u00ad some way.",
                    "sid": 9,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the other hand, there arc lan\u00ad guages that do not use word separators.",
                    "sid": 10,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A much more complicated processing is needed, closer to morphological analysis or part-of-speech tag\u00ad ging.",
                    "sid": 11,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Tokenizers designed for those languages arc generally very tied to a given system and language.",
                    "sid": 12,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, the gap becomes smaller when we look at sentence segmentation: a simplistic ap\u00ad proach would not be sufficient because of the ambiguity of punctuation signs.",
                    "sid": 13,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "And if we consider the segmentation of a document into higher-level units such as paragraphs, sections, and so on, we can notice that language becomes less relevant.",
                    "sid": 14,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These observations lead to the definition of our formalism for segmentation (not just tok enization) that considers the process indepen\u00ad dently from the language.",
                    "sid": 15,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "By describing a seg\u00ad mentation system formally, a clean distinction can be made between the processing itself and the linguistic data it uses.",
                    "sid": 16,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This entails the abil\u00ad ity to develop a truly multilingual system by us\u00ad ing a common segmentation engine for the vari\u00ad ous languages of the system; conversely, one can imagine evaluating several segmentation meth\u00ad ods by using the same set of data with different strategies.",
                    "sid": 17,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Sumo is the name of the proposed formal\u00ad ism, evolving from initial work by (Quint, 1999; Quint, 2000).",
                    "sid": 18,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Some theoretical works from the literature also support this approach: (Guo, 1997) shows that some segmentation techniques can be generalized to any language, regardless of their writing system.",
                    "sid": 19,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The sentence segmenter of (Palmer and Hearst, 1997) and the issues ra.isecl by (Habert et a!., 1998) prove that even in En\u00ad glish or French, segmentation is not so trivial.",
                    "sid": 20,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Lastly, (AltMokhtar, 1997) handles all kinds of presyntactic processing in one step, arguing that there are strong interactions between segmenta\u00ad tion and morphology.",
                    "sid": 21,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1 The Framework for Segmentation.",
                    "sid": 22,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1.1 Overview.",
                    "sid": 23,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "'fhe framework revolves around the document representation chosen for Sumo, which is a layered structure, each layer being a view of the document at a given level of segmentation.",
                    "sid": 24,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These layers are introduced by the author of the segmentation application as needed and are not imposed by Sumo.",
                    "sid": 25,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The example in section 3.1 uses a two-layer structure (figure 4) correspond\u00ad ing to two levels of segmentation, characters and words.",
                    "sid": 26,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To extend this to a sentence segmenter, a third level for sentences is added.These levels of segmentation can ha.ve a lin guistic or structural level, but \"artificial\" levels can be introduced as well when needed.",
                    "sid": 27,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "lt is also interesting to note that severa.l layers can belong to the same level.",
                    "sid": 28,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Jn the example of section :3.:3, the result structure can have an indefinite num\u00ad ber of levels, and all levels arc of the same kind.",
                    "sid": 29,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We call item the segmentation unit of a doc\u00ad ument at a given scgmcnt<ttion level (e.g. items of the word level are words).",
                    "sid": 30,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The document is then representee!",
                    "sid": 31,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "at every segmentation level in terms of its items; because segmentation is usu\u00ad ally ambiguous, item gmphs arc used to factorize all the possible segmentations.",
                    "sid": 32,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Ambiguity issues anfurther addressed in section 2.:3.",
                    "sid": 33,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The main processing paradigms of Sumo arc identification ancltmnsfonnalion.",
                    "sid": 34,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "With identifi\u00ad cation, new item graphs are built by identifying items from a source graph using a segmentation resoun:c. 'fhcse graphs arc then modified by transformation processes.",
                    "sid": 35,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Section 2 gives the details about both identification and transfor\u00ad mation.",
                    "sid": 36,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1.2 Item Graphs.",
                    "sid": 37,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The item graphs arc directed acyclic graphs; they arc similar to the word graphs of (Amtrup et a.l., l99G) or the string graphs of (Colmcr\u00ad auer, 1970).",
                    "sid": 38,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "They arc a.ctua.lly represented by means of finite-state automata (sec section :2.1).",
                    "sid": 39,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "!11 order to facilitate tlwir manipulation, two ad\u00ad ditional properties arc enforced: thcs<atttomata always have a single start-state and finite-state, and no dangling arcs (this is verified by pruning the automata after modifications).",
                    "sid": 40,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The exam\u00ad ple::; of scctiou 3 s!Jow various item graphs.",
                    "sid": 41,
                    "ssid": 41,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An item is an arc in the automaton.",
                    "sid": 42,
                    "ssid": 42,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An arc is a complex structure containing a label (gen\u00ad erally the surface form of tile item), named at\u00ad tributes and relations.",
                    "sid": 43,
                    "ssid": 43,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Attributes arc used to hold informa.tion on the item, like part of speech tags (sec section 3.2).",
                    "sid": 44,
                    "ssid": 44,
                    "kind_of_tag": "s"
                },
                {
                    "text": "These attributes can also be viewed as annotations in the same sense as the annotation graphs of (Bird ct al., 2000).",
                    "sid": 45,
                    "ssid": 45,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1.:3 Relations Relations are links between levels.",
                    "sid": 46,
                    "ssid": 46,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Items from a given graph arc linked to items of the graph from which they were identified.",
                    "sid": 47,
                    "ssid": 47,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We call the first graph the lower graph and the graph that was the source for the identification the upper graph.",
                    "sid": 48,
                    "ssid": 48,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Relations exist bctvvcen a. path in the upper graph and either a path or a subgra.ph in the lower graph.",
                    "sid": 49,
                    "ssid": 49,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 1 illustrates the first kind of relation, called palh relation.",
                    "sid": 50,
                    "ssid": 50,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This example in French is a. relation between the two characters of the word \"clu\" which is really a contraction of \"de lc\".",
                    "sid": 51,
                    "ssid": 51,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 1: A pat!J relation Figme 2 illustrates the other kind of relation called subgmph relation.",
                    "sid": 52,
                    "ssid": 52,
                    "kind_of_tag": "s"
                },
                {
                    "text": "J n this example the sentence \"A BCDEFC .\"",
                    "sid": 53,
                    "ssid": 53,
                    "kind_of_tag": "s"
                },
                {
                    "text": "(we can imagine that i\\ through G arc Chinese characters) is related to scvcra.l possible segmentations.",
                    "sid": 54,
                    "ssid": 54,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 2: A graph relation The interested reader may refer to (Planas, 1998) for a comparable stntctun(multiple lay\u00ad ers of a document and relations) used in trans\u00ad lation memory.",
                    "sid": 55,
                    "ssid": 55,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "processing a document. ",
            "number": "2",
            "sents": [
                {
                    "text": "2.1 Description of a Document.",
                    "sid": 56,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The core of the document representation is the item graph, which is represented by a finite\u00ad state automaton.",
                    "sid": 57,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Since regular expressions de\u00ad fine finite-state automata, they can be used to describe an item graph.",
                    "sid": 58,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, our expres\u00ad sions arc extended because the items arc more complex than simple symbols; new operators are introclucccl: \u2022 attributes are introduced by an@ sign; \u2022 path relations arc delimited by { and }; \u2022 the information concerning a given item are parenthesized using [ and ] . As an exemplc, the relation of figure 1 is de\u00ad scribed by the following expression: [de le {d u }] 2.2 Identification.",
                    "sid": 59,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Identification is the process of identifying new items from a source graph.",
                    "sid": 60,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Using the source graph and a. segmentation resource, new items arc built to form a. new graph.",
                    "sid": 61,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A segmentation resource, or simply resource, describes the vo\u00ad cabulary of the language, by defining a mapping between the source and the target level of seg\u00ad mentation.",
                    "sid": 62,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A resource is represented by a. finite\u00ad state transducer in Sumo; identification is per\u00ad formed by applying the transducer to the source automaton to produce the target automaton, like in regular finite-state calculus.",
                    "sid": 63,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Resources can be compiled by regular expres\u00ad sions or indcntifica.tion rules.",
                    "sid": 64,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Jn the former case, one can usc the usual operations of finite-state calculus to compile the resource: union, inter\u00ad section, composition, ctc.1 A benefit of the usc of Sumo structures to represent resources is that new resources can be built easily from the doc\u00ad ument that is being processed.",
                    "sid": 65,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "(Quint, 1999) shows how to extract proper nouns from a. text in order to extend the lexicon used by the seg\u00ad menter to provide more acurate results.",
                    "sid": 66,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the latter case, rules arc specified as shown in section 3.3.",
                    "sid": 67,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The left hand side of a rule de\u00ad scribes a subpath in the source graph, while the right hand side describes the associated subpath in the target graph.",
                    "sid": 68,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A path relation is created between the two sequences of items.",
                    "sid": 69,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "ln an iden\u00ad tification rule, one can introduce variables (for callback), and even calls to transformation func\u00ad tions (sec next section).",
                    "sid": 70,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Naturally, these possi\u00ad bilities cannot be expressed by a strict finite\u00ad state structure, even with our extended formal\u00ad ism; hence, calculus with the resulting struc\u00ad tures is limited.",
                    "sid": 71,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A special kind of identification is the auto\u00ad matic segmentation that takes place at the entry point of the process.",
                    "sid": 72,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A character graph can be created automatically by segmenting an input text document, knowing its encoding.",
                    "sid": 73,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This text document can be in raw form or XML format.",
                    "sid": 74,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Another possibility for input is to usc a graph 1The semantics of these operations is broadened to accomodate the more complex nature of the items.",
                    "sid": 75,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "of items that was created previously, either by Sumo, or converted to the format recognized by Sumo.",
                    "sid": 76,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "2.3 Transformation.",
                    "sid": 77,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Ambiguity is a central issue when talking about segmentation.",
                    "sid": 78,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The absence or ambiguity of word separators can lead to multiple segmen\u00ad tations, and more than one of them can have a. meaning.",
                    "sid": 79,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As (Sproat ct a.l., 1996) testify, several native Chinese speakers do not always agree on one unique tokeniza.tion for a. given sentence.",
                    "sid": 80,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Thanks to the use of item graphs, Sumo can handle ambiguity efficiently.",
                    "sid": 81,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Why try to fully disambiguate a tokeniza.tion when there is no agreement on a single best solution?",
                    "sid": 82,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Moreover, segmentation is usually just a basic step of pro\u00ad cessing in an NLP system, and some decisions may need more information than what a seg\u00ad menter is able to provide.",
                    "sid": 83,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "i\\n uninformed choice at this stage can affect the next stages in a. neg\u00ad ative way.",
                    "sid": 84,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Transformations are a way to mod\u00ad ify the item graphs so that the \"good\" paths (segmentations) can be kept and the \"bad\" ones discarded.",
                    "sid": 85,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We can also of course provide full disambiguation (see section 3.1 for instance) by means of transformations.",
                    "sid": 86,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In Sumo transformations are handled by transformation functions that manipulate the objects of the formalism: graphs, nodes, items, paths (a special kind of graph), etc. These func\u00ad tions are written using an imperative language illustrated in section 3.1.",
                    "sid": 87,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A transformation can either be applied directly to a graph or attached to a graph relation.",
                    "sid": 88,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the latter case, the orig\u00ad inal graph is not modified, and its transformed counterpart is only accessible through the rela\u00ad tion.",
                    "sid": 89,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Transformation functions allow to control the flow of the process, using looping and condition\u00ad als.",
                    "sid": 90,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An important implication is that a same resource can be applied iteratively; as shown by (Roche, 1994) this feature allows to implement segmentation models much more powerful than simple regular languages (see section 3.3 for an example).",
                    "sid": 91,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Another consequence is that a Sumo application consists of one big transformation function returning the completed Sumo struc\u00ad ture as a. result.",
                    "sid": 92,
                    "ssid": 37,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "examples of use. ",
            "number": "3",
            "sents": [
                {
                    "text": "3.1 Maxinnun tokenization.",
                    "sid": 93,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Some classic heuristics for tokeuizatiou a.re classified by (Guo, 1997) under the collective moniker of maximum lokcnizalion.",
                    "sid": 94,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This section describes how to implement a \"maximum tok\u00ad enizer\" that tokeniY:es raw text documents in a given language and character encoding (e.g. En\u00ad glish in ASCll, French in JsoLatin-1, Chinese in Big5 or GB).",
                    "sid": 95,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3.1.1 Conunon setup Our tokenizer is built with two levels: the in\u00ad put level is the character level, a.utoma.tically segnwutecl using the encoding information.",
                    "sid": 96,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The token level is built from these characters, first by an exl1austive icleutification of the tokens, then by reducing tlw number of paths to the one con\u00ad siclerccl the best by the JVIa.ximum Tokeniy;a.tion heuristic.",
                    "sid": 97,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The system works in three steps, with com\u00ad plete code shown in figure :3.",
                    "sid": 98,
                    "ssid": 6,
                    "kind_of_tag": "s"
                },
                {
                    "text": "First, the charac\u00ad ter level is created by automatic segmentation (lines l-5, input level being the :-;pecial graph tha.t is automatically created from a raw file through stdin).",
                    "sid": 99,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second step is to create the word graph by identifying words from character usiug a. dictionary.",
                    "sid": 100,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "J\\ rcsomce called ABCdic is created from a transducer rile (lines 68), theu the graph words is created by identifying items from the source level characters using tltc re\u00ad source ABCdic (lines 9-J 2).",
                    "sid": 101,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The third step is tlw disam bigua.tion of the word level by applying a Maximum 'l'okcniY:a.tion heuristic (line J :1).",
                    "sid": 102,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1 characters: input level { 2 encoding: <ASCII, UTF8, BigS...> 3 type: raw; 4 from: stdin; 5 } 6 ABCdic: resource {.",
                    "sid": 103,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "7 file: ''ABCdic.sumo''; 8 } 9 words: graph <- identify { 10 source: characters; 11 resource: ABCdic; 12 } 13 words<- ft(words.start-node); Figure 3: Maximum 'J'okeniy;er in Sumo Figure ;J illustrates the situation for the in\u00ad put string \"A BCDEFG\" where i\\ through G arc characters and A, AB, B, BC, BCDEF, C, CD, D, DE, E, F, FG and G a.re words found in the resource ABCdic.",
                    "sid": 104,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The situation shown is after line 12 and before line 13.",
                    "sid": 105,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 4: Exhaustive tokenization of the string ABCDEFG We will see in the next three subsections the diff'crent heuristics and their implementations in Sumo.",
                    "sid": 106,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3.1.2 Forward Maximum Tokenization Forward Maximum 'l'okeniY:ation consists of scanning the string from left to right and select\u00ad ing the token of maximum length any time an ambiguity occurs.",
                    "sid": 107,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the example of figure 4, the resu It.",
                    "sid": 108,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "tokeniY:ation of the iurmt string would be J\\BjCD/E/FG.",
                    "sid": 109,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 5 shows a function called ft that builds a path recursively by traversing the token graph, appending the longest item to the path at each node.",
                    "sid": 110,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "ft takes a node as input and rctums a. path (line J).",
                    "sid": 111,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "H the node is final, the empty path is returned (lines 2-:l), otlwrvvise the array of items of the uodes (n. i terns) is searched and the lougest item stored in longest (lines 410).",
                    "sid": 112,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Tile returned path consists of this longest item prepencled to the longest path starting from the destination node of this item (line 11).",
                    "sid": 113,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3.1.3 Backward Maxim.mu Tokenization l3ackward Maximum 'J'okeniY:a.tion is the same as Forvvard Maximum 'J'okenization except that the string is scanned from right to left, instead of left to right.",
                    "sid": 114,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the example of figure !J, the tokenization of the input string would yield A/BC/DE/FG under Backward Maximum 'J'o\u00ad kenization.",
                    "sid": 115,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A function bt can be written.",
                    "sid": 116,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "lt is very sim\u00ad ilar to ft, except that it works backward by looking at incoming arcs of the considered node.",
                    "sid": 117,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "bt is called on the final state of the graph and 1 function ft (n: node) -> path { 2 if final(n) { 3 return(); 4 }else { 5 longest: item <- n.items[1]; 6 foreach it in n.items[2..]{ 7 if it.length > longest.length { 8 longest <- it; 9 } 10 } 1 function st (g:graph) -> path { 2 d: list<- (); II distances 3 p: list<- (); II predecessors 4 foreach n in (g.nodes){ 5 d[n] = integer.max; II ''infinite'' 6 } 7 foreach n: node in t_sort(g.nodes){ 8 foreach it in n.items { 9 if (d[it.dest]> d[n]+ 1)then { 10 d[it.dest] = d[n] + 1; 11 return (longest# ft(longest.dest)); 11 p[it.dest] = n; 12 } 13 } Figure 5: The ft function stops when at the initial node.",
                    "sid": 118,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Another imple\u00ad mentation of this function is to apply ft on the reversed graph and then reversing the path ob\u00ad tained.",
                    "sid": 119,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3.1.4 Shortest Tokenization Shortest Tokenilmtion is concerned with mini\u00ad mizing the overall number of tokens in the text.",
                    "sid": 120,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the example of figure 4, the tokenir,ation of the input string would yield A/BCDEF/G un\u00ad der shortest tokenization.",
                    "sid": 121,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 6 shows a function called st that finds the shortest path in the graph.",
                    "sid": 122,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "This function is adapted from an algorithm for single-source shortest paths discovery in a DAG given by (Carmen et al., 1990).",
                    "sid": 123,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "lt calls another func\u00ad tion, t_sort, returning a list of the nodes of the graph in topological order.",
                    "sid": 124,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The initializations are clone in lines 26, the core of the algorithm is in the loop of lines 714 that computes the short\u00ad est path to every node, storing for each node its \"predecessor\".",
                    "sid": 125,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Lines 1520 then build the path, which is returned in line 21.",
                    "sid": 126,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3.1.5 Combination of Maximum Tokenization techniques One of the features of Sumo is to allow the com\u00ad parison of different segmentation strategies us\u00ad ing the same set of data.",
                    "sid": 127,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As we have just seen, the three strategies described above can indeed be compared efficiently by modifying only part of the third step of the processing.",
                    "sid": 128,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Letting the system run three times on the same set of input documents can then give three different sets of results to be compared by the author of the sys\u00ad tem (against each other and against a reference tokenization, for instance).",
                    "sid": 129,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "12 } 13 } 14 } 15 n <- g.end; II end state 16 sp: path<- (n); II path 17 while (n != g.start) { 18 n = p[n]; 19 sp = (n # sp); 20 } 21 return sp; 22 } Figure 6: the st function And yet a different setup for our \"maximum tokenizer\" would be to select not just the op\u00ad timal path according to one of the heuristics, but the paths selected by the three of them, as shown in figure 7.",
                    "sid": 130,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Combining the three paths into a graph is performed by changing line 1:3 in figure 3 to: words <- ft(words.start-node) I bt(words.end-node) I st(words.start-node); Figure 7: Three maximum tokenizations 3.2 Statistical Tokenization and Part of.",
                    "sid": 131,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Speech Tagging This example shows a more complicated tok\u00ad enization system, using the same sort of setup as the one from section 3.1, with a disambigua\u00ad tion process using statistics (namely, a big ram model).",
                    "sid": 132,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Our reference for this model is the Chasen Japanese tokenizer and part of speech tagger documented in ( J\\11 a.tsumoto et a.l., 1999).",
                    "sid": 133,
                    "ssid": 41,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1'his example is a. high-level description of how to implement a simila.r system with Sumo.",
                    "sid": 134,
                    "ssid": 42,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The setup for this example adds a. uew level to the previous example: the \"bigra.m level.\"",
                    "sid": 135,
                    "ssid": 43,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The word level is still built by id( ntifica.tion us\u00ad ing dictionaries, then the bigram level is built by computing a. connectivity cost betvvecn each pair of tokens.",
                    "sid": 136,
                    "ssid": 44,
                    "kind_of_tag": "s"
                },
                {
                    "text": "'J'his is the level that will be used for disambiguation or selection of the best solutions.",
                    "sid": 137,
                    "ssid": 45,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 9: Connectivity costs for W with its modified cost.",
                    "sid": 138,
                    "ssid": 46,
                    "kind_of_tag": "s"
                },
                {
                    "text": "We write the following rule and apply it to the word graph to create the bigram graph: 3.2.1 Exhaustive Segmentation All possible segmentations are derived from the [$w1 = . \u00a9.]",
                    "sid": 139,
                    "ssid": 47,
                    "kind_of_tag": "s"
                },
                {
                    "text": "[$w2 -> eval(f($w1, $2)) . \u00a9.]",
                    "sid": 140,
                    "ssid": 48,
                    "kind_of_tag": "s"
                },
                {
                    "text": "character level to create the word level.",
                    "sid": 141,
                    "ssid": 49,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The resource used for this is a. dictionary of the lan\u00ad guage that maps the surface form of the words (in terms of their characters) to their base form, part of sp( ech, and a cost (Chasc11 a.lso adds pronunciation, conjugation type, and sema.nt.ic information).",
                    "sid": 142,
                    "ssid": 50,
                    "kind_of_tag": "s"
                },
                {
                    "text": "J\\ ll this inform at ion is stored iu the item as attributes, the base form being used a.s the la.bel for the item.",
                    "sid": 143,
                    "ssid": 51,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure t3 shows the identification of the word \"ca.ts\" which is identi\u00ad fied as \"cat\", with category \"noun\" (i.e. @CAT:=N) a.ncl with some cost/;; (@COST=k).",
                    "sid": 144,
                    "ssid": 52,
                    "kind_of_tag": "s"
                },
                {
                    "text": "o c \u00b70 a < _ ) t ...o_ -s ,..( 1 \"( /_) cat @CATN @COST k(_)- - -- Figure 8: lclentifica.tion of the word \"cats\" 3.2.2 Statistical Disambiguation The disambiguation method relics on a bigram model: each pa.ir of successive items has a \"con\u00ad nectivity cost\".",
                    "sid": 145,
                    "ssid": 53,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the bigram level, the \"cost\" attribute of' an item \\V will be the connectiv\u00ad ity cost of W and a following item X. Note that if a same W can be followed by several items X, Y, etc. with different connectivity costs for This ndc can he read as: for any word $w1 with any attribute(\" . 11 matches any label,\"@ . 11 any set of attributes) followed by any word $w2 with any attribute (\"_11 being a context separa\u00ad tor), create the item returned by the function f ($w1, $w2).",
                    "sid": 146,
                    "ssid": 54,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Disam bigua.tion is then be performed by se\u00ad lecting the path with optimal cost in this graph; but we can also select all paths with a cost cor\u00ad responding to a certain threshold or the n best pathR, etc. Note also tl1at this model is easily ex\u00ad tensible to any kind of n-grams.",
                    "sid": 147,
                    "ssid": 55,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A new function f ($w1, ...",
                    "sid": 148,
                    "ssid": 56,
                    "kind_of_tag": "s"
                },
                {
                    "text": ", $wn) must be provided to com\u00ad pute the connectivity costs of this sequence of items, and the above rule must be modified to take a. larger context into accmu1t.",
                    "sid": 149,
                    "ssid": 57,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3.3 A Fonnal Example This last exam pie is more formal and serves as an illustration of some powerful features of Sumo.",
                    "sid": 150,
                    "ssid": 58,
                    "kind_of_tag": "s"
                },
                {
                    "text": "(Colmerauer, 1970) has a Rimilar exam\u00ad ple implemented using Q systems.",
                    "sid": 151,
                    "ssid": 59,
                    "kind_of_tag": "s"
                },
                {
                    "text": "ln both cases the goal is to transform an input string of the form anlJ''c\"\", n ::0: 0 into a single item 8 (as\u00ad suming th<tt the input alphabet does not contain S'), meaning that the input string is a word of this language.",
                    "sid": 152,
                    "ssid": 60,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The setup here is once again to start with a lower level automatically created from the input, each pair then W will be replicated with a. dif\u00ad then to build intermediat e levels until a final level containing only the item S is produced (at ferent \"cosC1 attribute.",
                    "sid": 153,
                    "ssid": 61,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 9 shows a word W followed by either X or Y, with two different connectivity costs /.; and /;;'.",
                    "sid": 154,
                    "ssid": 62,
                    "kind_of_tag": "s"
                },
                {
                    "text": "'J'he implementation ofthis tcclmique in Sumo is straightforward.",
                    "sid": 155,
                    "ssid": 63,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Assume there is a fundiou f that, given two items1 computee> their connec\u00ad tivity cost (depending on both of their category, individual cost, etc.) and returns the first item which point the input is recognized), or until the process can no longer carry on (at which point the iuput is rejected).",
                    "sid": 156,
                    "ssid": 64,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The building of intermediary levels is handled by tile identification rule below: # S?",
                    "sid": 157,
                    "ssid": 65,
                    "kind_of_tag": "s"
                },
                {
                    "text": "a [$A=a*]b [$B=b*] c [$c=c*] # -> S $A $B $C What this rule docs is identify a string of the form S?aa*bb*cc*, storing all a's but the first one in the variable $A, all b's but the first one in $B and all c's but the first one in $C. The flrst triplet abc (with a possible S in front) is then absorbed by S, and the remaining a's, b's and c's are rewritten after S. Figure 10 illustrates the first application of this rule to the input sequence aabbcc, creating the first intermediate level; subsequent applica\u00ad tions of this rule will yield the only item 8.",
                    "sid": 158,
                    "ssid": 66,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 10: First application of the rule Conclusion We have described the main features of Sumo, a dedicated formalism for segmentation of text.",
                    "sid": 159,
                    "ssid": 67,
                    "kind_of_tag": "s"
                },
                {
                    "text": "i\\ document is represented by item graphs at dif\u00ad ferent levels of segmentation, which allows mul\u00ad tiple segmentations of the same document at the same time.",
                    "sid": 160,
                    "ssid": 68,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Three detailed examples illus\u00ad trated the features of Sumo discussed here.",
                    "sid": 161,
                    "ssid": 69,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For the sake of simplicity some aspects could not be evoked in this paper, they include: manage\u00ad ment of the segmentation resources, efficiency of the systems written in Sumo, larger applica\u00ad tions, evaluation of segmentation systems.",
                    "sid": 162,
                    "ssid": 70,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Sumo is currently being prototyped by the au\u00ad thor.",
                    "sid": 163,
                    "ssid": 71,
                    "kind_of_tag": "s"
                }
            ]
        }
    ]
}