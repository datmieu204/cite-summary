{
    "ID": "P06128",
    "sections": [
        {
            "text": "abstract",
            "number": 0,
            "sents": [
                {
                    "text": "Linear text segmentation aims at dividing a long text into several topical segments.",
                    "sid": 1,
                    "ssid": 1,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It is beneficial to many natural language processing tasks, such as information retrieval and document summarization.",
                    "sid": 2,
                    "ssid": 2,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this article, an efficient linear text segmentation algorithm based on hierarchical agglomerative clustering is presented.",
                    "sid": 3,
                    "ssid": 3,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The proposed linear text segmentation algorithm is implemented without auxiliary knowledge base, parameter setting, and user involvement.",
                    "sid": 4,
                    "ssid": 4,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Experimental results show that the proposed linear text segmentation algorithm not only provides linear time computational complexity, but also provides comparable segmentation accuracy with several well- known linear text segmentation algorithms.",
                    "sid": 5,
                    "ssid": 5,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Keywords-text segmentation; hierarchical agglomerative clustering, computational intelligence, NLP application",
                    "sid": 6,
                    "ssid": 6,
                    "kind_of_tag": "s"
                }
            ]
        },
        {
            "text": "introduction",
            "number": "1",
            "sents": [
                {
                    "text": "The purpose of linear text segmentation is to divide a long text into several segments, each of which corresponds to a topic and consists of consecutive sentences or paragraphs.",
                    "sid": 7,
                    "ssid": 7,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In other words, the task of linear text segmentation is to identify topic boundaries within a long text.",
                    "sid": 8,
                    "ssid": 8,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Linear text segmentation algorithms are widely used as an essential step in many natural language processing tasks, such as information retrieval and document summarization.",
                    "sid": 9,
                    "ssid": 9,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In information retrieval, to segment a long document into distinct topics is useful because only the topical segments relevant to the user\u2019s needs are retrieved [1].",
                    "sid": 10,
                    "ssid": 10,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It not only provides more accurate information to the user, but also reduces the user\u2019s burden to read the whole document.",
                    "sid": 11,
                    "ssid": 11,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In document summarization, a long document is often divided into topics and then each topic is summarized independently [2].",
                    "sid": 12,
                    "ssid": 12,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A text segmentation algorithm is usually applied as the first step of these tasks.",
                    "sid": 13,
                    "ssid": 13,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Segmentation accuracy and computational complexity are two critical issues in linear text segmentation algorithm design.",
                    "sid": 14,
                    "ssid": 14,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the past, many well-known linear text segmentation algorithms have been proposed [3, 4, 5, 6].",
                    "sid": 15,
                    "ssid": 15,
                    "kind_of_tag": "s"
                },
                {
                    "text": "9780-76954584-4/11 $26.00 \u00a9 2011 IEEE DOI 10.1109/CIS.2011.240 1081 Although it has been proven that these algorithms either improve the segmentation accuracy or provide efficient processing of linear text segmentation, they can hardly deal with both issues at the same time.",
                    "sid": 16,
                    "ssid": 16,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Some algorithms provide better segmentation accuracy, but suffer from expensive computational complexity; some algorithms provide efficient processing of linear text segmentation, but suffer from lower segmentation accuracy [7].",
                    "sid": 17,
                    "ssid": 17,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In recent years, some algorithms, such as TSF [7], are proposed to provide high segmentation accuracy in a reasonable processing time.",
                    "sid": 18,
                    "ssid": 18,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, most of the algorithms rely heavily on a training phase or manpower to designate parameters used in the algorithms.",
                    "sid": 19,
                    "ssid": 19,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The training phase is time consuming, while to designate parameters by manpower increases user\u2019s burden.",
                    "sid": 20,
                    "ssid": 20,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Moreover, it is difficult to determine manually suitable parameters.",
                    "sid": 21,
                    "ssid": 21,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To tackle the problems mentioned above, a novel efficient linear text segmentation algorithm based on Hierarchical Agglomerative Clustering (HAC) is presented in this article.",
                    "sid": 22,
                    "ssid": 22,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The proposed linear text segmentation algorithm dynamically designates parameters according to the metadata of a text, and hence neither training data nor user involvement is needed.",
                    "sid": 23,
                    "ssid": 23,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In other words, the algorithm requires only the given text, no other information or preprocessing is needed.",
                    "sid": 24,
                    "ssid": 24,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It not only reduces the user\u2019s burden, but also increases the utility of the proposed linear text segmentation algorithm.",
                    "sid": 25,
                    "ssid": 25,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Segmentation accuracy of the proposed linear text segmentation algorithm is evaluated with a most commonly used test collection, created by Choi [3].",
                    "sid": 26,
                    "ssid": 26,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Also, the computational complexity of the proposed algorithm is analyzed.",
                    "sid": 27,
                    "ssid": 27,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Experimental results show that the proposed algorithm not only provides comparable segmentation accuracy with several well-known linear text segmentation algorithms, but also provides a linear time computational complexity without any auxiliary knowledge base, parameter setting, or user involvement.",
                    "sid": 28,
                    "ssid": 28,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Existing text segmentation algorithms can be divided into two major categories [3].",
                    "sid": 29,
                    "ssid": 29,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The first category is lexical cohesion methods.",
                    "sid": 30,
                    "ssid": 30,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second category is multi-source methods.",
                    "sid": 31,
                    "ssid": 31,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Lexical cohesion methods detect cohesion using word stem repetition, context vectors, entity repetition, semantic similarity, word distance model, and word frequency model.",
                    "sid": 32,
                    "ssid": 32,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Multi-source methods combine lexical cohesion with other indicators of topic shift, including cue phrase, prosodic features, reference, syntax and lexical attraction using decision trees and probabilistic models.",
                    "sid": 33,
                    "ssid": 33,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the literatures, some efficient linear text segmentation algorithms are proposed, such as TextTiling [5].",
                    "sid": 34,
                    "ssid": 34,
                    "kind_of_tag": "s"
                },
                {
                    "text": "TextTiling is a well-known linear time text segmentation algorithm proposed by Hearst.",
                    "sid": 35,
                    "ssid": 35,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It uses a sliding window approach to segment a text.",
                    "sid": 36,
                    "ssid": 36,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The similarities between adjacent blocks within the text are computed to detect topic changes.",
                    "sid": 37,
                    "ssid": 37,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The computed similarities are smoothed, and used to identify topic boundaries by a cutoff function.",
                    "sid": 38,
                    "ssid": 38,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Although TextTiling is an efficient linear text segmentation method (the complexity is linear time), it suffers from lower segmentation accuracy.",
                    "sid": 39,
                    "ssid": 39,
                    "kind_of_tag": "s"
                },
                {
                    "text": "There are some more complex linear text segmentation algorithms, such as C99 [3].",
                    "sid": 40,
                    "ssid": 40,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Sentence-similarity matrix, consists of similarities between all sentences within a text, is frequently adopted in these algorithms.",
                    "sid": 41,
                    "ssid": 41,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For example, C99 proposed by Choi [3] segments a text by combining a rank matrix, transformed from the sentence-similarity matrix, and divisive clustering.",
                    "sid": 42,
                    "ssid": 42,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Some algorithms apply the similarity matrix to detect the optimal topic boundaries by using dynamic programming [4, 6].",
                    "sid": 43,
                    "ssid": 43,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Owing to the cost of constructing the sentence-similarity matrix is O(n2), where n represents the number of sentences in a text, such algorithms suffer from higher computational complexity [7].",
                    "sid": 44,
                    "ssid": 44,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To tackle the problems observed above, Kern and Granitzer proposed an efficient linear text segmentation algorithm, called TSF [7].",
                    "sid": 45,
                    "ssid": 45,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Similar to TextTiling, TSF identifies topic boundaries using a sliding window.",
                    "sid": 46,
                    "ssid": 46,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The differences between TSF and TextTiling are: 1) in TSF, a term vector is built per sentence, instead of merging all terms within a block into one term vector in TextTiling; 2) both the inner similarity\u02b3 of a block of sentences and the outer similarity of adjacent blocks of sentences are considered when evaluating a potential segmentation position.3) In TSF\u02b3 the smoothing happens implicitly by using the average of the sentence similarities, instead of smoothing the similarity between adjacent blocks in TextTiling.",
                    "sid": 47,
                    "ssid": 47,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It has been proven that TSF has an O(n) computational complexity, and provides a comparable accuracy when compared with several higher computational complexity algorithms.",
                    "sid": 48,
                    "ssid": 48,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, two parameters need to be provided by the user, say the size of block and the threshold to identify candidate topic boundaries.",
                    "sid": 49,
                    "ssid": 49,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It may increase the user\u2019s burden and the parameters provided may not always be suitable to reflect the linear time complexity, i.e., O(n).",
                    "sid": 50,
                    "ssid": 50,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Especially, no parameter setting is required.",
                    "sid": 51,
                    "ssid": 51,
                    "kind_of_tag": "s"
                },
                {
                    "text": "III.",
                    "sid": 52,
                    "ssid": 52,
                    "kind_of_tag": "s"
                },
                {
                    "text": "TEXT SEGMENTATION BASED ON HIERARCHICAL AGGLOMERATIVE CLUSTERING (TSHAC) In this section, an efficient linear text segmentation algorithm (called TSHAC), which considers both computational complexity and segmentation accuracy, is proposed.",
                    "sid": 53,
                    "ssid": 53,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The process of TSHAC consists of 4 steps.",
                    "sid": 54,
                    "ssid": 54,
                    "kind_of_tag": "s"
                },
                {
                    "text": "At first, a long text is preprocessed; tokenization, stopword removal, and stemming are conducted to construct the vocabulary of the text.",
                    "sid": 55,
                    "ssid": 55,
                    "kind_of_tag": "s"
                },
                {
                    "text": "After text preprocessing, the text can be represented as vectors, each of which represents a sentence within the text.",
                    "sid": 56,
                    "ssid": 56,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A part of sentence similarities are then computed to construct the sentence-similarity matrix.",
                    "sid": 57,
                    "ssid": 57,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Finally, the optimal topic boundaries are identified by the proposed algorithm.",
                    "sid": 58,
                    "ssid": 58,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A. Text Preprocessing In general, the process of text preprocessing can be divided into 3 stages: 1) tokenization; 2) stopword removal; 3) stemming.",
                    "sid": 59,
                    "ssid": 59,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Punctuation is firstly removed from a long text, and the sentences within the text are then converted into a stream of words.",
                    "sid": 60,
                    "ssid": 60,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Subsequently, generic stopwords are removed.",
                    "sid": 61,
                    "ssid": 61,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The rest of words are stemmed and regarded as the vocabulary of the long text.",
                    "sid": 62,
                    "ssid": 62,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In 2003, Ji et al. [6] devise a new idea of document- dependent stopword removal.",
                    "sid": 63,
                    "ssid": 63,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In contrast to the fixed set of generic stopwords, document-dependent stopwords are the words that are useful in discriminating among several different documents but are rather harmful in detecting subtopics in a document.",
                    "sid": 64,
                    "ssid": 64,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Both generic stopword removal and document-dependent stopword removal are adopted in our proposed linear text segmentation algorithm.",
                    "sid": 65,
                    "ssid": 65,
                    "kind_of_tag": "s"
                },
                {
                    "text": "B. Text Representation Given a long text T, a sentence sj contained in T can be represented as a vector in order: s j = {w1 j , w2 j ,..., wij ,...wkj } where wij represents the word weight of the ith word in sj; k represents the total number of words in the vocabulary V constructed from the long text.",
                    "sid": 66,
                    "ssid": 66,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In our proposed algorithm, wij can be computed by any formula, such as TFxIDF, that the word weight can be suitably represented.",
                    "sid": 67,
                    "ssid": 67,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As the core contribution of the proposed algorithm is the process of hierarchical agglomerative clustering for linear text segmentation, here we use the same formula as in TSF for comparison purpose.",
                    "sid": 68,
                    "ssid": 68,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The word weight wij is computed by a variant of TFxIDF [7]: real metadata.",
                    "sid": 69,
                    "ssid": 69,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Based on the above observations, an efficient linear text segmentation algorithm based on Hierarchical wij = termFreqij tokenCount j (log( docCount docFreqi + 1 ) + 1) , Agglomerative Clustering (HAC) [8] will be presented in the next section.",
                    "sid": 70,
                    "ssid": 70,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The proposed linear text segmentation where termFreqij represents the occurrences of word i in sentence j; tokenContj represents the total number of words from a corpus; docFreqi represents the total number of documents contain word i. C. Sentence-Similarity Matrix Construction In previous researches, the sentence-similarity matrix is usually constructed by computing the similarities of all pairs of sentences within a text.",
                    "sid": 71,
                    "ssid": 71,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The similarity of two sentences is usually computed by cosine measurement: \u00a6 wik w jk , Co sin e(s , s ) = k Segmentation Hierarchical Agglomerative Clustering (HAC) [8] is a bottom-up hierarchical clustering method.",
                    "sid": 72,
                    "ssid": 72,
                    "kind_of_tag": "s"
                },
                {
                    "text": "It has been successfully applied to many applications.",
                    "sid": 73,
                    "ssid": 73,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In TSHAC, a sentence is used as the basic processing unit.",
                    "sid": 74,
                    "ssid": 74,
                    "kind_of_tag": "s"
                },
                {
                    "text": "For more efficient process of linear text segmentation, in the first step, a text is roughly divided into several blocks of sentences by the method mentioned in the last subsection.",
                    "sid": 75,
                    "ssid": 75,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each block is then regarded as an independent cluster.",
                    "sid": 76,
                    "ssid": 76,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In each merging stage, the similarities between a cluster and its neighbors are measured by the following formula: i j 2 2 ik jk k k 2 \u00d7 \u00a6 \u00a6 sim(s m , s n ) sm \u2208ci sn \u2208c j , (1) where si represents the ith sentence and sj represents the jth sentence in text T respectively.",
                    "sid": 77,
                    "ssid": 77,
                    "kind_of_tag": "s"
                },
                {
                    "text": "As mentioned in Section II, the construction of such a sentence-similarity matrix costs Sim(ci , c j ) = (| ci | + | c j |) \u2212 STDEV O(n2), where n represents the number of sentences.",
                    "sid": 78,
                    "ssid": 78,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To reduce the cost, TSHAC computes only the similarities alongside the main diagonal according to the block size, instead of the complete sentence-similarity matrix.",
                    "sid": 79,
                    "ssid": 79,
                    "kind_of_tag": "s"
                },
                {
                    "text": "At first, the similarities between each sentence and its neighbors are computed.",
                    "sid": 80,
                    "ssid": 80,
                    "kind_of_tag": "s"
                },
                {
                    "text": "If the similarity between two adjacent sentences is equal to 0, the sentences are divided into different blocks.",
                    "sid": 81,
                    "ssid": 81,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Hence, text T is roughly divided into several blocks, each of which is composed of consecutive sentences.",
                    "sid": 82,
                    "ssid": 82,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Subsequently, the number of sentences in the largest block is regarded as the block size.",
                    "sid": 83,
                    "ssid": 83,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The similarities alongside the diagonal of the sentence-similarity matrix are then computed according to the block size.",
                    "sid": 84,
                    "ssid": 84,
                    "kind_of_tag": "s"
                },
                {
                    "text": "where Sim(ci, cj) represents the similarities of cluster i and cluster j. The first part of (1) represents the lexical cohesion.",
                    "sid": 85,
                    "ssid": 85,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The numerator is the total similarities of sentences from ci with the sentences from cj.",
                    "sid": 86,
                    "ssid": 86,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The denominator is used to normalize the lexical cohesion to the range [0, 1].",
                    "sid": 87,
                    "ssid": 87,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The second part of (1) represents the standard deviation of the cluster size (i.e., number of sentences in a cluster) after ci and cj are merged into a group.",
                    "sid": 88,
                    "ssid": 88,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In general cases, the number of sentences in each cluster is similar.",
                    "sid": 89,
                    "ssid": 89,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Based on this observation, smaller standard deviation of the cluster size is preferred [9].",
                    "sid": 90,
                    "ssid": 90,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The standard deviation of the cluster size is computed by the following equation: For example, assume that the block size is 2, only the elements (i, j) under i = 1, 2, \u2026, 7 and j = i + 1, i + 2, i + 3 (i.e., 2 \u036a block size - 1), where j < 7, are computed.",
                    "sid": 91,
                    "ssid": 91,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Each element (i, j) in the sentence-similarity represents the STDEV = #cluster \u00a6( clusterj \u2212 \u03bc ) j =1 , # cluster similarity between sentences i and j (i.e., Cosine(si, sj)).Because all the elements in the diagonal of the sentence similarity matrix are equal to 1 and the sentence-similarity matrix is symmetric, only the upper triangle of the sentence- similarity matrix needs to be computed.",
                    "sid": 92,
                    "ssid": 92,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An example of the sentence-similarity matrix is shown as Fig.",
                    "sid": 93,
                    "ssid": 93,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1.",
                    "sid": 94,
                    "ssid": 94,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The construction of the sentence-similarity matrix is similar to TSF [7].",
                    "sid": 95,
                    "ssid": 95,
                    "kind_of_tag": "s"
                },
                {
                    "text": "However, in the proposed algorithm, the block size is dynamically determined according to the metadata of a text, instead of statically provided by the user.",
                    "sid": 96,
                    "ssid": 96,
                    "kind_of_tag": "s"
                },
                {
                    "text": "where \u03bc represents the average number of sentences within clusters.",
                    "sid": 97,
                    "ssid": 97,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Because the sentences within a text are located in order, only adjacent clusters need to be considered in each merging stage (i.e., only Sim(ci1, ci) and Sim(ci, ci+1) need to be computed).",
                    "sid": 98,
                    "ssid": 98,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The nearest pair of adjacent clusters is then merged into a new cluster.",
                    "sid": 99,
                    "ssid": 99,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The merging process is repeated until all clusters are merged into one universal cluster.",
                    "sid": 100,
                    "ssid": 100,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A hierarchical cluster tree is then constructed as shown in Fig.",
                    "sid": 101,
                    "ssid": 101,
                    "kind_of_tag": "s"
                },
                {
                    "text": "2.",
                    "sid": 102,
                    "ssid": 102,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1 2 3 4 5 6 7 1 2 3 4 5 6 7 0.1 0.2 0.4 0.6 0.7 0.8 c1 c2 c3 c4 c5 c6 c7 Figure 2.",
                    "sid": 103,
                    "ssid": 103,
                    "kind_of_tag": "s"
                },
                {
                    "text": "An example of a hierarchical cluster tree.",
                    "sid": 104,
                    "ssid": 104,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Figure 1.",
                    "sid": 105,
                    "ssid": 105,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Upper triangle of the sentence-similarity matrix.",
                    "sid": 106,
                    "ssid": 106,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In order to divide the text into several topical segments, after the hierarchical cluster tree is constructed, the input data objects can be divided into several clusters, each of which represents a topic, by cutting the hierarchical cluster tree at a feasible height.",
                    "sid": 107,
                    "ssid": 107,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A fitness function is proposed to evaluate each of the potential height hi of the hierarchical cluster tree constructed as follow: #seg \u22121 \u00a6 dissimilarity j contain less than or equal to 2 sentences is also considered.",
                    "sid": 108,
                    "ssid": 108,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A lower proportion of short segments is preferred in our fitness function.",
                    "sid": 109,
                    "ssid": 109,
                    "kind_of_tag": "s"
                },
                {
                    "text": "E. The Proposed TSHAC Algorithm The complete process of TSHAC is summarized as Fig.",
                    "sid": 110,
                    "ssid": 110,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3.",
                    "sid": 111,
                    "ssid": 111,
                    "kind_of_tag": "s"
                },
                {
                    "text": "IV.",
                    "sid": 112,
                    "ssid": 112,
                    "kind_of_tag": "s"
                },
                {
                    "text": "PERFORMANCE EVALUATIONS To evaluate the performance of TSHAC, a publicly available test corpus is adopted.",
                    "sid": 113,
                    "ssid": 113,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The test corpus was created f (hi ) = j =1 # seg \u2212 STDEV (i) \u2212 # seg len\u2264 2 (2) # s e g by Choi [3] and has been commonly used in previous researches.",
                    "sid": 114,
                    "ssid": 114,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The test corpus consists of 700 samples.",
                    "sid": 115,
                    "ssid": 115,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A sample is a concatenation of ten text segments.",
                    "sid": 116,
                    "ssid": 116,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A segment is As mention in previous researches [9], when dividing a long text into several topical segments, the sentences within a topical segment should cover the same subtopic.",
                    "sid": 117,
                    "ssid": 117,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Moreover, sentences among different segments should belong to different subtopics.",
                    "sid": 118,
                    "ssid": 118,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore, both the average sentence similarity within each segment (inner similarity) and the average sentence similarity between two consecutive segments (outer similarity) are considered in the fitness function.",
                    "sid": 119,
                    "ssid": 119,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The inner similarity and the outer similarity are then combined as dissimilarity [7] as follows: the first n sentences of a randomly selected document from the Brown corpus.",
                    "sid": 120,
                    "ssid": 120,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The 700 samples are divided into 4 sets according to the range of the number of sentences.",
                    "sid": 121,
                    "ssid": 121,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Table I shows the statistics of the test corpus, n represents the number of sentences.",
                    "sid": 122,
                    "ssid": 122,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To compare with several well-known text segmentation algorithms, including TextTiling [5], C99 [3], U00 [10], TopSeg02 [11], AniDiffDynProg03 [6], and TSF [7], the commonly used segmentation metric proposed by Beeferman [12] is adopted: sim inner \u2212 sim outer p(error|ref, hyp, k ) = dissimilarity j = j j sim inner , where p(miss|ref, hyp, diffe rent ref s egments, k ) p(diff ref s egments|re f, k ) + p( false alar m|ref, hyp , same ref segment, k ) p(same ref s egment|ref , k ) \u03bc ( B pre , B pre ) + \u03bc ( B post , B post ) The aim of the segmentation metric is to compute the error probability of a randomly chosen pair of words at distance k sim inner = j j j 2 j and words apart that is inconsistently classified.",
                    "sid": 123,
                    "ssid": 123,
                    "kind_of_tag": "s"
                },
                {
                    "text": "ref represents the tru e se g men tation and hy p repr e se n t s t h e prop o sed sim j = \u03bc B j B j , The proposed TSHAC algorithm Input: A long text.",
                    "sid": 124,
                    "ssid": 124,
                    "kind_of_tag": "s"
                },
                {
                    "text": "outer ( pre , post ) Output: Several topical segments.",
                    "sid": 125,
                    "ssid": 125,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Step 1.",
                    "sid": 126,
                    "ssid": 126,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Preprocess a text by tokenization, generic stopword removal, where \u03bc represents average pairwise sentence similarities of document-dependent stopword removal, and stemming.",
                    "sid": 127,
                    "ssid": 127,
                    "kind_of_tag": "s"
                },
                {
                    "text": "two blocks; pre i represents the block of sentences that Step 2.",
                    "sid": 128,
                    "ssid": 128,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Deter mine block size by the method mentioned in Section III-C.",
                    "sid": 129,
                    "ssid": 129,
                    "kind_of_tag": "s"
                },
                {
                    "text": "precede the potential boundary; B post represents the block Step 3.",
                    "sid": 130,
                    "ssid": 130,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Compute the similarities of sentences alongside the diagonal of sentences that succeed the potential boundary.",
                    "sid": 131,
                    "ssid": 131,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The higher dissimilarityj implies higher feasibility of the potential boundary.",
                    "sid": 132,
                    "ssid": 132,
                    "kind_of_tag": "s"
                },
                {
                    "text": "On the other hand, the standard deviation of the segment length (as shown in (3)) is also considered in the fitness function.",
                    "sid": 133,
                    "ssid": 133,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Because the number of sentences in different segment is usually similar [9], a lower standard deviation value of segment size is preferred when we design the fitness function.",
                    "sid": 134,
                    "ssid": 134,
                    "kind_of_tag": "s"
                },
                {
                    "text": "# seg \u00a6( seg j \u2212 \u03bc) of the sentence-similarity matrix with the block size.",
                    "sid": 135,
                    "ssid": 135,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Step 4.",
                    "sid": 136,
                    "ssid": 136,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Segment the text by the following steps: Step 4.1.",
                    "sid": 137,
                    "ssid": 137,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The text is roughly divided into several groups by the method mentioned in Section III-C and each group is regarded as an independent cluster.",
                    "sid": 138,
                    "ssid": 138,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Step 4.2.",
                    "sid": 139,
                    "ssid": 139,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Compute the similarities between adjacent clusters by (1).",
                    "sid": 140,
                    "ssid": 140,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Step 4.3.",
                    "sid": 141,
                    "ssid": 141,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Merge the pair of clusters to achieve the greatest similarity.",
                    "sid": 142,
                    "ssid": 142,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Step 4.4.",
                    "sid": 143,
                    "ssid": 143,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Repeat Step 4.2 and Step 4.3 until only one universal cluster left.",
                    "sid": 144,
                    "ssid": 144,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Step 4.5.",
                    "sid": 145,
                    "ssid": 145,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Cut the hierarchical cluster tree by the predesigned fitness function (shown as (2)) to achieve the highest fitness value.",
                    "sid": 146,
                    "ssid": 146,
                    "kind_of_tag": "s"
                },
                {
                    "text": "STDEV(i) = j =1 # seg (3) Figure 3.",
                    "sid": 147,
                    "ssid": 147,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The porposed TSHAC algorithm.",
                    "sid": 148,
                    "ssid": 148,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Finally, a topic segment usually contains several sentences that could well describe a topic.",
                    "sid": 149,
                    "ssid": 149,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To avoid topic segments to be too short, the number of segments which TABLE I. STATISTICS OF THE TEST CORPUS segmentation.",
                    "sid": 150,
                    "ssid": 150,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The error probability is composed of the miss and the false alarm probabilities.",
                    "sid": 151,
                    "ssid": 151,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The miss probability is a conditional probability that the randomly chosen pair of words spans a segment boundary for the true segmentation, but lies in the same segment for the proposed segmentation.",
                    "sid": 152,
                    "ssid": 152,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The false alarm probability is a conditional probability that the randomly chosen pair of words lies in the same segment for the true segmentation, but spans a segment boundary for the proposed segmentation.",
                    "sid": 153,
                    "ssid": 153,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The lower error probability implies higher segmentation accuracy.",
                    "sid": 154,
                    "ssid": 154,
                    "kind_of_tag": "s"
                },
                {
                    "text": "A. Computational Complexity Analysis As mentioned above, the construction of the complete similarity matrix cost O(n2), where n is the number of sentences in a text.",
                    "sid": 155,
                    "ssid": 155,
                    "kind_of_tag": "s"
                },
                {
                    "text": "To reduce the time complexity, in the proposed algorithm, only the similarities alongside the diagonal are computed with the block size.",
                    "sid": 156,
                    "ssid": 156,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore, the time complexity is O(nk), where n represents the number of sentences and k represents the block size.",
                    "sid": 157,
                    "ssid": 157,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In this article, the proposed linear text segmentation algorithm is based on HAC.",
                    "sid": 158,
                    "ssid": 158,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Unlike the general process of HAC, only the similarities between each cluster and its neighbors are computed at each merging stage.",
                    "sid": 159,
                    "ssid": 159,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore, in contrast to the general HAC, which takes O(n2), the proposed TSHAC algorithm compute only the similarities between the newly merged cluster and its two neighbors in each merging stage, and hence it takes only O(n).",
                    "sid": 160,
                    "ssid": 160,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Moreover, the roughly grouping of sentences into blocks will further improve the efficiency of the proposed linear text segmentation algorithm.",
                    "sid": 161,
                    "ssid": 161,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The actual complexity of the HAC process will be less than or equal to O(n).",
                    "sid": 162,
                    "ssid": 162,
                    "kind_of_tag": "s"
                },
                {
                    "text": "According to the above analysis, TSHAC is a linear time algorithm of linear text segmentation.",
                    "sid": 163,
                    "ssid": 163,
                    "kind_of_tag": "s"
                },
                {
                    "text": "B. Experimental Results Table II shows the error probability of TSHAC and several well-known text segmentation algorithms.",
                    "sid": 164,
                    "ssid": 164,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Among these algorithms, TextTiling, TSF and TSHAC are linear time algorithms, and the others are non-linear time algorithms [7].",
                    "sid": 165,
                    "ssid": 165,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The error probability of the well-known linear text segmentation algorithms are collected from the literatures [3, 7].",
                    "sid": 166,
                    "ssid": 166,
                    "kind_of_tag": "s"
                },
                {
                    "text": "The experimental results in Table II are reported when the number of segments is unknown in advance.",
                    "sid": 167,
                    "ssid": 167,
                    "kind_of_tag": "s"
                },
                {
                    "text": "From Table II, the proposed linear text segmentation algorithm (i.e., TSHAC) outperforms the linear time algorithm, TextTiling, and the more complex algorithms, C99.",
                    "sid": 168,
                    "ssid": 168,
                    "kind_of_tag": "s"
                },
                {
                    "text": "TSHAC also provides comparable results with other algorithms.",
                    "sid": 169,
                    "ssid": 169,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Moreover, unlike TSF, which requires manpower to designate parameters used, TSHAC provides a fully automatic process for linear text segmentation without auxiliary knowledge base, parameter setting, or user involvement.",
                    "sid": 170,
                    "ssid": 170,
                    "kind_of_tag": "s"
                },
                {
                    "text": "V. CONCLUSION AND FUTURE WORKS The contributions of this article include: 1) Propose a high performance linear text segmentation algorithm based on HAC; 2) The proposed linear text segmentation algorithm TABLE II.",
                    "sid": 171,
                    "ssid": 171,
                    "kind_of_tag": "s"
                },
                {
                    "text": "EXPERIMENTAL RESULTS AND COMPARISON 3 1 1 3 5 6 8 9 1 1 T e x t T i l i n g 4 6 % 4 4 % 4 3 % 4 8 % C 9 9 1 3 % 1 8 % 1 0 % 1 0 % U 0 0 1 1 % 1 3 % 6 % 6 % T o p S e g 10.",
                    "sid": 172,
                    "ssid": 172,
                    "kind_of_tag": "s"
                },
                {
                    "text": "74 % 7.",
                    "sid": 173,
                    "ssid": 173,
                    "kind_of_tag": "s"
                },
                {
                    "text": "44 % 7.",
                    "sid": 174,
                    "ssid": 174,
                    "kind_of_tag": "s"
                },
                {
                    "text": "95 % 6.",
                    "sid": 175,
                    "ssid": 175,
                    "kind_of_tag": "s"
                },
                {
                    "text": "75 % An iDi ffD yn Pro g03 6.",
                    "sid": 176,
                    "ssid": 176,
                    "kind_of_tag": "s"
                },
                {
                    "text": "0 % 7.",
                    "sid": 177,
                    "ssid": 177,
                    "kind_of_tag": "s"
                },
                {
                    "text": "1 % 5.",
                    "sid": 178,
                    "ssid": 178,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3 % 4.",
                    "sid": 179,
                    "ssid": 179,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3 % T S F 9.",
                    "sid": 180,
                    "ssid": 180,
                    "kind_of_tag": "s"
                },
                {
                    "text": "0 % 9.",
                    "sid": 181,
                    "ssid": 181,
                    "kind_of_tag": "s"
                },
                {
                    "text": "3 % 6.",
                    "sid": 182,
                    "ssid": 182,
                    "kind_of_tag": "s"
                },
                {
                    "text": "8 % 9.",
                    "sid": 183,
                    "ssid": 183,
                    "kind_of_tag": "s"
                },
                {
                    "text": "2 % T S H A C 9.",
                    "sid": 184,
                    "ssid": 184,
                    "kind_of_tag": "s"
                },
                {
                    "text": "84 % 9.",
                    "sid": 185,
                    "ssid": 185,
                    "kind_of_tag": "s"
                },
                {
                    "text": "26 % 8.",
                    "sid": 186,
                    "ssid": 186,
                    "kind_of_tag": "s"
                },
                {
                    "text": "23 % 7.",
                    "sid": 187,
                    "ssid": 187,
                    "kind_of_tag": "s"
                },
                {
                    "text": "54 % achieves comparable segmentation accuracy with efficient processing time; 3) The parameters used in the process of linear text segmentation are automatically designated without auxiliary knowledge base, parameter setting, or user involvement.",
                    "sid": 188,
                    "ssid": 188,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Therefore, the proposed linear text segmentation algorithm is feasible for segmenting long texts in real time, especially when user involvement is unavailable.",
                    "sid": 189,
                    "ssid": 189,
                    "kind_of_tag": "s"
                },
                {
                    "text": "Furthermore, the proposed algorithm not only provides topical segments, but also provides hierarchical discourse structure of the text, if necessary.",
                    "sid": 190,
                    "ssid": 190,
                    "kind_of_tag": "s"
                },
                {
                    "text": "In the future, we plan to implement the proposed linear text segmentation algorithm in some real world applications.",
                    "sid": 191,
                    "ssid": 191,
                    "kind_of_tag": "s"
                }
            ]
        }
    ]
}